local item_by_community = {}
local item_dependence = {}
local item_count = {}
local always_keep_item = {}
local item_by_story_id
local death_ini = ini_file("misc\\death_generic.ltx")

function init_drop_settings()
	-- Create a list by community of the percent chance to spawn an item
	local community_list = { "stalker", "dolg", "freedom", "bandit", "army", "zombied", "ecolog", "killer", "monolith", "csky" }
	for k,v in pairs(community_list) do
		item_by_community[v] = {}
		if death_ini:section_exist(v) then
			local n = death_ini:line_count(v)
			local id, value = "", ""
			for i=0,n-1 do
				result, id, value	= death_ini:r_line(v,i,"","")
				item_by_community[v][id] = tonumber(value) or 0
			end
		end
	end

	local n = death_ini:line_count("item_count")
	local id, value = "", ""
	for i=0,n-1 do
		local result, id, value	= death_ini:r_line("item_count",i,"","")
		local p = alun_utils.str_explode(value,",")
		if (p and p[1] and p[2]) then
			item_count[id] = {tonumber(p[1]) or 0,tonumber(p[2]) or 0}
		end
	end
	
	-- Create a list of spawn sections that depend on the existence of other items
	local n = death_ini:line_count("item_dependence")
	local id, value = "", ""
	for i=0,n-1 do
		local result, id, value	= death_ini:r_line("item_dependence",i,"","")
		item_dependence[id] = {}
		local vvv = parse_names(value)
		for k,v in pairs(vvv) do
			item_dependence[id][v] = true
		end
	end

 	-- Create a list of item sections that npc must keep
	local n = death_ini:line_count("keep_items")
	for i=0,n-1 do
		local result, id, value	= death_ini:r_line("keep_items",i,"","")
		if value == "true" then
			always_keep_item[id] = true
		end
	end
	
	-- Create a list of item sections that npc must keep
	local n = death_ini:line_count("spawn_by_story_id")
	for i=0,n-1 do
		if not (item_by_story_id) then 
			item_by_story_id = {}
		end
		local result, id, value	= death_ini:r_line("spawn_by_story_id",i,"","")
		item_by_story_id[id] = value
	end
end

class "drop_manager"
function drop_manager:__init(npc)
	self.npc = npc
end
function drop_manager:create_release_item()
	--' Спрашиваем у серверного объекта генерились ли предметы
	-- Alundaio
	local death_dropped = xr_logic.pstor_retrieve(self.npc,"death_dropped",false)
	if (death_dropped) then
		return
	end
	xr_logic.pstor_store(self.npc,"death_dropped",true)
	-- Alundaio

	self.npc:iterate_inventory(keep_item, self.npc)
	
	-- spawn items by story id 
	local sid = item_by_story_id and get_object_story_id(self.npc:id())
	if (sid and item_by_story_id[sid]) then
		local p = alun_utils.str_explode(item_by_story_id[sid],",")
		if (p) then
			for i,v in pairs(p) do
				create_items(self.npc, v, 1, 100)
			end
		end
	end

	local ini = self.npc:spawn_ini()
	if ini and ini:section_exist("dont_spawn_loot") then
		return
	end
	local st		= db.storage[self.npc:id()]
	local st_ini 	= st and st.ini
	if st_ini and st_ini:line_exist(st.section_logic , "dont_spawn_loot") then
		return
	end

	local spawn_items = item_by_community[character_community(self.npc)]
	if spawn_items == nil then
		return
	end
	for sec,v in pairs(spawn_items) do
		if (v > 0 and item_count[sec] and check_item_dependence(self.npc, sec) == true) then
			local number = math.ceil(math.random(item_count[sec][1], item_count[sec][2]))
			--' Необходимо заспавнить нужное количество.
			create_items(self.npc, sec, number, v)
		end
	end

end

--' Функция вызывается для каждого предмета, если вернет false то предмет удалится.
function keep_item(npc, item)
	if not (item) then 
		return 
	end 
	
	local section = item:section()
	if (always_keep_item[section]) then 
		return 
	end 
	
	local ini = npc:spawn_ini()
	if ini and ini:section_exist("dont_keep_items") then
		local se_item = alife():object(item:id())
		if (se_item) then
			alife():release(se_item, true)
		end
		return
	end
	local st = db.storage[npc:id()]
	local st_ini = st and st.ini
	if st_ini and st_ini:line_exist(st.section_logic , "dont_keep_items") then
		local se_item = alife():object(item:id())
		if (se_item) then
			alife():release(se_item, true)
		end
		return
	end
	
	-- release all animation objects
	if (section == "bolt" or section == "medkit_script" or section == "guitar_a" or section == "harmonica_a" or section == "wpn_binoc" or section == "anim_binoc" or section == "anim_knife" 
		or section == "device_torch" or section == "device_pda" or section == "hand_radio" or section == "hand_radio_r") then
		local se_item = alife():object(item:id())
		if (se_item) then
			alife():release(se_item, true)
		end
		return 
	end
	
	local m = item:get_max_uses()
	if (m > 0) then 
		local r = math.random(0,m)
		if (r == 0) then 
			local se_item = alife():object(item:id())
			if (se_item) then
				alife():release(se_item, true)
			end
		end
		item:set_remaining_uses(r)
		return
	end
	
	if IsArtefact(item) then
		return
	end

	local cls = item:clsid()
	if IsWeapon(item,cls) and not(cls==clsid.wpn_grenade_rgd5_s or cls==clsid.wpn_grenade_f1_s) then
		set_weapon_drop_condition(item)
		return
	end
	
	if (item:is_ammo() ~= true and xr_corpse_detection.lootable_table and xr_corpse_detection.lootable_table[section] and math.random(1,100) < 65) then
		return
	end
	
	local se_item = alife():object(item:id())
	if (se_item) then
		alife():release(se_item, true)
	end
end

function set_weapon_drop_condition(item)
	local condition  = (math.random(40)+30)/100
	--printf("condition [%s]", tostring(condition))
	item:set_condition(condition)
end

--' Функция спавнит необходимое число предметов
function create_items(npc, section, number, rnd)
	if not (system_ini():section_exist(section)) then 
		printf("death_manager: ERROR: trying to spawn section that doesn't exist!")
		return 
	end 
	
	printf("death_dropped: create %s=%s",section,number)
	if _G.ammo_section[section] == true then
		if number > 0 then
			create_ammo(section,npc:position(),npc:level_vertex_id(),npc:game_vertex_id(),npc:id(),number)
		end
	else
		for i=1,number do
			--' Проверяем вероятность появить каждый объект в отдельности
			if math.random() <=  rnd then
				alife():create(section,npc:position(),npc:level_vertex_id(),npc:game_vertex_id(),npc:id())
			end
		end
	end
end

--' Функция проверяет есть ли хоть один из зависимых объектов у персонажа
function check_item_dependence(npc, section)
	if item_dependence[section] == nil then
		return true
	end

	local d_flag = true
	for k,v in pairs(item_dependence[section]) do
		local obj = npc:object(k)
		if obj ~= nil and npc:marked_dropped(obj) ~= true then
			return true
		end
		d_flag = false
	end

	return d_flag
end

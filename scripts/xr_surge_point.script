------------------------------------------------------------------------------------
--    xr_surge_point
-- Auto-generated point_jobs around surge covers for gulag_general
-- by Alundaio

-- TODO: Finish and implement in gulag_general
------------------------------------------------------------------------------------

evaid = 17001
actid = 17001

local used_vids = {}

------------------------------------------------------------------------------------
local alife, vector, level, mrand = alife, vector, level, math.random
------------------------------------------------------------------------------------


function on_game_start()
	--load_scheme("xr_surge_point","surge_point",0)
	--callback_register("scheme_set",set_scheme)
end

-----------------------------------------------------

class "evaluator_need_job" (property_evaluator)
function evaluator_need_job:__init(storage, name) super(nil, name)
  	self.st = storage
end
function evaluator_need_job:evaluate()
  	return xr_logic.is_active(self.object, self.st)
end

----------------------------------------------------------------------------------------------------------------------
class "action_point_surge" (action_base)
function action_point_surge:__init (npc_name, action_name, storage) super(nil, action_name)
	self.st = storage
end

function action_point_surge:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
	self.object:set_path_type(game_object.level_path)
end

function action_point_surge:activate_scheme()
	local vid,look
	if (self.st.smart) then
		count = 1
		local paths = {}
		
		if (level.patrol_path_exists(self.st.smart.."_surge_job_point")) then 
			paths[#paths] = self.st.smart.."_surge_job_point"
		end 
		
		while level.patrol_path_exists(self.st.smart.."_surge_job_point_"..count) do 
			count = count + 1 
			paths[#paths] = self.st.smart.."_surge_job_point_"..count
		end 
		
		local path = paths[math.random(#paths)]
		if (path) then 
			local pos = patrol(path):point(0)
			local t = {}
			local function create_surge_point(pos,dir)
				local radius = 8
				local vertex_id = 4294967295
				local tmp_pos = vector():set(0,0,0)
				while (vertex_id >= 4294967295) do
					tmp_pos.x = pos.x + dir.x * radius
					tmp_pos.z = pos.z + dir.z * radius
					tmp_pos.y = pos.y

					vertex_id = level.vertex_id(tmp_pos)
					if (vertex_id >= 4294967295 or used_vids[vertex_id]) then
						if (radius > 1) then
							radius = radius - 1
						else
							break
						end
					end
				end
				return vertex_id
			end

			local dir = vector():set(0,0,0)

			t[#t+1] = pos
			for i=1,6 do
				vid = create_surge_point(pos,vector_rotate_y(dir,i*60))
				look = pos
				if (vid and vid < 4294967295 and not used_vids[vid]) then 
					break 
				end
			end
			
			-- fallback
			if (vid == nil or vid >= 4294967295 or used_vids[vid]) then
				local pos = t and #t > 0 and t[math.random(#t)] or self.object:position()
				vid = alun_utils.find_random_cover(self.object,pos,5,15)
				look = pos
			end
		end
	end
	
	-- fallback
	if (vid == nil or used_vids[vid]) then
		local smart = self.st.smart and SIMBOARD:get_smart_by_name(self.st.smart) or xr_gulag.get_npc_smart(self.object)
		local pos = smart and smart.position or self.object:position()
		vid = alun_utils.find_random_cover(self.object,pos,5,15)
		look = pos
	end
	
	self.st.signals = {}
	self.st.look_position = look
	self.st.vid = utils.send_to_nearest_accessible_vertex(self.object,vid or self.object:level_vertex_id())
	state_mgr.set_state(self.object,xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.reach_movement))
	
	used_vids[self.st.vid] = true
end

function action_point_surge:execute()
	action_base.execute(self)

	if not (self.st.vid) then 
		return 
	end 
	
	local npc = self.object
	if not (npc:level_vertex_id() == self.st.vid) then
		if (npc:path_type() ~= game_object.level_path) then 
			npc:set_path_type(game_object.level_path)
		end
		self.st.vid = utils.send_to_nearest_accessible_vertex(npc,self.st.vid,"xr_surge_point")
		state_mgr.set_state(npc,xr_logic.pick_section_from_condlist(db.actor, npc, self.st.reach_movement))
		return
	end

	local tg = time_global()

	local anim = xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.anim)
	state_mgr.set_state(self.object, anim, nil, nil, {look_position = self.st.look_position})
end


function action_point_surge:finalize()
	action_base.finalize(self)
	if (self.st.vid) then
		used_vids[self.st.vid] = nil
	end
end

function action_point_surge:position_riched()
	return self.cover_position:distance_to_sqr(self.object:position()) <= 0.4
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	local wp = world_property
	local manager = npc:motivation_action_manager()

	-- evaluators
	manager:add_evaluator(evaid, this.evaluator_need_job(storage, "need_cover"))

	local new_action = this.action_point_surge(npc, "action_point_surge", storage)
	new_action:add_precondition( wp(stalker_ids.property_alive,true) )
	new_action:add_precondition( wp(stalker_ids.property_danger,false) )
	--new_action:add_precondition( wp(xr_danger.evaid,false) )
	new_action:add_precondition( wp(stalker_ids.property_enemy,false) )
	new_action:add_precondition( wp(stalker_ids.property_anomaly,false) )
	new_action:add_precondition( wp(xr_evaluators_id.sidor_wounded_base,false) )
	new_action:add_precondition( wp(evaid,true) )

	new_action:add_effect( wp(evaid,false) )
	new_action:add_effect ( wp(xr_evaluators_id.state_mgr + 4, false) )
	manager:add_action(actid, new_action)

	xr_logic.subscribe_action_for_events(npc, storage, new_action)

	-- actions
	new_action = manager:action(xr_actions_id.alife)
	new_action:add_precondition( wp(evaid, false) )
	new_action = manager:action(xr_actions_id.state_mgr + 2)
	new_action:add_precondition( wp(evaid, false) )
end

function set_scheme(npc, ini, scheme, section, gulag_name, stype)
	local st = xr_logic.assign_storage_and_bind(npc, ini, "campfire_point", section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.smart = utils.cfg_get_string(ini, section, "smart", npc, false, "")
	st.anim	= xr_logic.parse_condlist(npc, "anim", "anim", utils.cfg_get_string(ini, section, "anim", npc, false, "", "hide"))
	st.reach_movement = xr_logic.parse_condlist(npc, "reach_movement", "reach_movement", utils.cfg_get_string(ini, section, "reach_movement", npc, false, "", "patrol"))

	local use_camp = xr_logic.parse_condlist(npc, "use_camp", "use_camp", utils.cfg_get_string(ini, section, "use_camp", npc, false, "", "false"))
	st.use_camp = xr_logic.pick_section_from_condlist(db.actor, npc, use_camp) == "true"
end

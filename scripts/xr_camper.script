--'	Схема кемпер. Чудак с бальшой пушкой ходит и отстреливает живность.
--'	автор: Диденко Руслан (Stohe)
----------------------------------------------------------------------------------------------------------------------
-- EVALUATORS
----------------------------------------------------------------------------------------------------------------------
--' Условие завершения скрипта
class "evaluator_end" (property_evaluator)
function evaluator_end:__init(name, storage) super (nil, name)
	self.st = storage
end

function evaluator_end:evaluate()
	--alun_utils.debug_write("xr_camper:eva_end")
	local object = self.object
	local db_st = db.storage[object:id()]
	if (db_st) and (db_st.corpse_detection and db_st.corpse_detection.selected_corpse_id) then 
		return false 
	end
	if (IsWounded(object)) then 
		return false 
	end
	return not xr_logic.is_active(object, self.st)
end

--' Обычный комбат или кемперский
class "evaluator_close_combat" (property_evaluator)
function evaluator_close_combat:__init(name, storage) super (nil, name)
	self.st = storage
end

function evaluator_close_combat:evaluate()
	--alun_utils.debug_write("xr_camper:eva_close_combat")
	local object = self.object
	local st = self.st
	local db_st = db.storage[object:id()]
	if not xr_logic.is_active(object, st) or
		(db_st and db_st.rx_dont_shoot) or
		xr_danger.has_danger(object) then
		return true
	end
	local be = object:best_enemy()
	if not (be) then
		return false
	end
	--[[
	local a = object:memory_time(be)
	if a then
		if (time_global() - a < 20000 and object:position():distance_to(object:memory_position(be)) < st.radius) then
			return true
		end
	end
	--]]
	-- ^
	if (st.locked or object:position():distance_to(be:position()) < st.radius) then
		st.locked = true
		return true 
	end
	return false
end
----------------------------------------------------------------------------------------------------------------------
-- ACTIONS
----------------------------------------------------------------------------------------------------------------------
--' Патрулировать территорию по патрульному пути
class "action_patrol" (action_base)
function action_patrol:__init (npc,action_name,storage) super (nil,action_name)
	self.st = storage
	self.move_mgr = db.storage[npc:id()].move_mgr
	self.st.scan_table = {}
end

function action_patrol:initialize()
	action_base.initialize(self)
	local object = self.object
	object:set_desired_position()
	object:set_desired_direction()
	self:reset_scheme()
	self.enemy_position = nil
end

function action_patrol:reset_scheme()
	--alun_utils.debug_write("action_patrol:reset_scheme")
	local object = self.object
	state_mgr.set_state(object, "patrol")
	local st = self.st
	st.signals = {}
	st.scan_table = {}
	local st_path_walk = st.path_walk
	local st_path_look = st.path_look
	if st.sniper == true then
		self.move_mgr:reset(st_path_walk,utils.path_parse_waypoints(st_path_walk),nil,nil,nil,st.suggested_state,{obj=self,func=self.process_point})
		local path = st_path_look and patrol(st_path_look)
		if path ~= nil then
			local st_scan_table = st.scan_table
			for k = 0, path:count() - 1 do
				for i = 0, 31 do
					if path:flag(k, i) then
						if st_scan_table[i] == nil then
							st_scan_table[i] = {}
						end
						local t = st_scan_table[i]
						t[#t+1] = {key = k, pos = path:point(k)}
					end
				end
			end
		end
		if (object:sniper_update_rate() == false) then
			object:sniper_update_rate(true)
		end
	else
		self.move_mgr:reset(st_path_walk,utils.path_parse_waypoints(st_path_walk),st_path_look,utils.path_parse_waypoints(st_path_look),nil,st.suggested_state,{obj=self,func=self.process_point})
		if object:sniper_update_rate() == true then
			object:sniper_update_rate(false)
		end
	end
	st.last_look_point = nil
	st.cur_look_point = nil
	st.scan_begin = nil
end

function action_patrol:activate_scheme()
	self:reset_scheme()
end

function action_patrol:can_shoot()
	local st = self.st
	return st.shoot == "always" or st.shoot == "terminal" and self.move_mgr:standing_on_terminal_waypoint() or false
end

function action_patrol:execute()
	--alun_utils.debug_write("action_patrol:execute")
	action_base.execute (self)
	local npc = self.object
	local be = npc:best_enemy()
	local tg = time_global()
	local st = self.st
	local st_sniper = st.sniper
	local move_mgr = self.move_mgr
	if not (be) then
		if (self:process_danger()) then
			return
		end
		if (self:on_place()) then
			if (st_sniper and st.wp_flag) then 
				self.scantime = self.scantime or tg
				self:scan(st.wp_flag)
				if not (move_mgr:standing_on_terminal_waypoint()) and (self.scantime and tg - self.scantime >= st.scantime_free) then
					move_mgr:continue()
					move_mgr:update()
				end
			else 
				move_mgr:continue()
				move_mgr:update()
				self.scantime = nil
			end
		else 
			move_mgr:continue()
			move_mgr:update()
			self.scantime = nil
		end
		return
	end
	local npc_position = npc:position()
	if (npc:see(be) and self:can_shoot()) then
		if (self.__keep_body_state_until == nil or tg > self.__keep_body_state_until) then
			local be_position = be:position()
			local dir = vector():sub(be_position, npc_position)
			self.__keep_body_state_until = tg + 3000
			if (npc:body_state() ~= move.crouch) then
				--if not (math.abs(be_position.y - npc_position.y) > 3.5) then
					if (level.high_cover_in_direction(npc:level_vertex_id(),dir) < 0.2) then 
						self.stand = false
					end
				--end
			else
				if (math.abs(be_position.y - npc_position.y) > 3.5) or (level.high_cover_in_direction(npc:level_vertex_id(),dir) >= 0.2) then 
					self.stand = true 
				end
			end
		end
		local dir = vector():sub(alun_utils.safe_bone_pos(be,"bip01_neck"),npc:bone_position("bip01_r_finger02"))
		if (self.stand) then 
			state_mgr.set_state(npc,st_sniper and "threat_sniper_fire" or "threat_fire", nil, nil, {look_object = be}, {fast_set = true})
		else 
			state_mgr.set_state(npc,st_sniper and "hide_sniper_fire" or "hide_fire", nil, nil, {look_object = be}, {fast_set = true})
		end
		--xr_sound.set_sound_play(npc:id(), st.attack_sound)
		return
	end
	local memory_position = npc:memory_position(be)
	if (memory_position) and (self.enemy_position == nil or not utils.vector_cmp(memory_position,self.enemy_position)) then 
		self.enemy_position = vector():set(memory_position)
		if st_sniper == true then
			local enemy_position = self.enemy_position
			local position = vector():set(npc_position)
			local direction = vector():set(enemy_position.x - position.x,0,enemy_position.z - position.z)
			direction:normalize()
			local wide_sight = npc_position:distance_to(enemy_position) * math.tan(st.enemy_disp)
			self.point_0 = vector():set(enemy_position.x + wide_sight * direction.z, enemy_position.y, enemy_position.z - wide_sight * direction.x)
			self.point_2 = vector():set(enemy_position.x - wide_sight * direction.z, enemy_position.y, enemy_position.z + wide_sight * direction.x)
			local st_scan_table = st.scan_table
			st_scan_table[-1] = {}
			local tbl = st_scan_table[-1]
			tbl[1] = {key = 0, pos = self.point_0}
			tbl[2] = {key = 1, pos = enemy_position}
			tbl[3] = {key = 2, pos = self.point_2}
		end
	end
	local mem_time = npc:memory_time(be)
	local enemy_position = self.enemy_position
	if (self:on_place()) then
		if (self.__keep_body_state_until == nil or tg > self.__keep_body_state_until) then
			local dir = enemy_position and vector():sub(enemy_position, npc_position) or npc:direction()
			self.__keep_body_state_until = tg + 3000
			if (npc:body_state() ~= move.crouch) then
				--if not (math.abs(enemy_position.y - npc_position.y) > 3.5) then
					if (level.high_cover_in_direction(npc:level_vertex_id(),dir) < 0.2) then 
						self.stand = false
					end
				--end
			else
				if (enemy_position and math.abs(enemy_position.y - npc_position.y) > 3.5) or (level.high_cover_in_direction(npc:level_vertex_id(),dir) >= 0.2) then 
					self.stand = true 
				end
			end
		end
		local stand = self.stand
		if st_sniper then 
			if (mem_time and tg - mem_time < st.post_enemy_wait) then
				if stand then 
					state_mgr.set_state(npc, "threat_na", nil, nil, {look_position = enemy_position})
				else 
					state_mgr.set_state(npc, "hide_na", nil, nil, {look_position = enemy_position})
				end
			else
				self:scan(-1)
			end
		else
			if stand then 
				state_mgr.set_state(npc, "threat_na", nil, nil, {look_position = enemy_position})
			else 
				state_mgr.set_state(npc, "hide_na", nil, nil, {look_position = enemy_position})
			end
		end
		return
	end
	if (mem_time and time_global() - mem_time > st.idle) then
		move_mgr:continue()
	end
	move_mgr:update()
end

function action_patrol:process_danger()
	local object = self.object
	local best_danger = object:best_danger()
	if best_danger == nil then
		return false
	end
	local best_danger_object = best_danger:object()
	local bd_type = best_danger:type()
	local tg = time_global()
	local passed_time = tg - best_danger:time()
	local urgent_danger = best_danger_object and (IsMonster(best_danger_object) or (IsStalker(best_danger_object) and object:relation(best_danger_object) >= game_object.enemy)) and (bd_type == danger_object.attacked) and passed_time < 3000
	if not (urgent_danger and xr_danger.has_danger(object)) then
		return false
	end
	if self.danger ~= true then
		self.danger = true
		object:play_sound(stalker_ids.sound_alarm, 1, 0, 1, 0)
	end
	local bd_pos = urgent_danger and best_danger_object:position() or best_danger:position()
	if (self.__keep_body_state_until == nil or tg > self.__keep_body_state_until) then
		local dir = bd_pos and vector():sub(bd_pos, object:position()) or object:direction()
		self.__keep_body_state_until = tg + 3000
		if (object:body_state() ~= move.crouch) then
			if (level.high_cover_in_direction(object:level_vertex_id(),dir) < 0.2) then 
				self.stand = false
			end	
		else
			if (level.high_cover_in_direction(object:level_vertex_id(),dir) >= 0.2) then 
				self.stand = true 
			end
		end
	end
	if (self.stand) then 
		state_mgr.set_state(object, "threat_na", nil, nil, {look_position = bd_pos})
	else 
		state_mgr.set_state(object, "hide_na", nil, nil, {look_position = bd_pos})
	end
	return true
end

function action_patrol:scan(flag)
	local st = self.st
	if (flag == nil or st.scan_table[flag] == nil) then
		return
	end
	if self.flag ~= flag then
		self.flag = flag
		st.scan_begin = nil
		st.cur_look_point = nil
		st.last_look_point = nil
	end
	if st.scan_begin == nil or
		 time_global() - st.scan_begin > st.time_scan_delta then
		self.next_point = self:get_next_point(flag)
		if st.cur_look_point == nil then
			st.cur_look_point = 1
		end
		local next_point = self.next_point
		if st.last_look_point == nil then
			st.last_look_point = next_point
		end
		--printf("Look at [%s][%s]", utils.to_str(st.last_look_point.key), utils.to_str(st.cur_look_point))
		self.look_position = st.last_look_point.pos
		self.dest_position = next_point.pos
		local look_pos = self.look_position
		local dest_position = self.dest_position
		local scandelta = st.scandelta
		self.look_point = vector():set(look_pos.x + st.cur_look_point * (dest_position.x - look_pos.x) / scandelta,
										 look_pos.y + st.cur_look_point * (dest_position.y - look_pos.y) / scandelta,
										 look_pos.z + st.cur_look_point * (dest_position.z - look_pos.z) / scandelta)
		local look_point = self.look_point
		local npc = self.object
		local tg = time_global()
		if (self.__keep_body_state_until==nil or tg > self.__keep_body_state_until) then
			local dir = look_point and vector():sub(look_point, npc:position()) or npc:direction()
			self.__keep_body_state_until = tg + 3000
			if (npc:body_state() ~= move.crouch) then
				if (level.high_cover_in_direction(npc:level_vertex_id(),dir) < 0.2) then 
					self.stand = false
				end	
			else
				if (level.high_cover_in_direction(npc:level_vertex_id(),dir) >= 0.2) then 
					self.stand = true 
				end
			end
		end
	
		if (self.stand) then 
			state_mgr.set_state(npc, "threat_na", nil, nil, {look_position = look_point})
		else 
			state_mgr.set_state(npc, "hide_na", nil, nil, {look_position = look_point})
		end
		
		if st.cur_look_point >= scandelta then
			st.cur_look_point = nil
			st.last_look_point = next_point
		else
			if st.scan_begin ~= nil then
				st.cur_look_point = st.cur_look_point + (time_global() - st.scan_begin)/st.time_scan_delta
			else
				st.cur_look_point = st.cur_look_point + 1
			end
		end
		st.scan_begin = time_global()
	end
end

function action_patrol:get_next_point(flag)
	local next = false
	local st = self.st
	local st_scan_table_flag = st.scan_table[flag]
	local last_look_point = st.last_look_point
	if last_look_point == nil then
		table.sort(st_scan_table_flag, function(a,b) return a.key < b.key end)
	end
	-- print_table(st_scan_table_flag)
	for k,v in pairs(st_scan_table_flag) do
		if last_look_point == nil then
			return v
		end
		if next == true then
			return v
		end
		if last_look_point.key == v.key then
			next = true
		end
	end
	if next == true then
		if last_look_point.key == 0 then
			table.sort(st_scan_table_flag, function(a,b) return a.key < b.key end)
		else
			table.sort(st_scan_table_flag, function(a,b) return a.key > b.key end)
		end
	end
	return last_look_point
end

function action_patrol:process_point(mode, number)
	return false
end

function action_patrol:finalize()
	self.move_mgr:finalize()
	action_base.finalize (self)
end

function action_patrol:on_place()
	local st = self.st
	if st.no_retreat == true then return false end
	local path_walk = st.path_walk
	local path = patrol(path_walk)
	if path ~= nil then
		for k = 0, path:count() - 1 do
			if utils.stalker_at_waypoint(self.object, patrol(path_walk), k) then
				for i = 0, 31 do
					if path:flag(k, i) then
						st.wp_flag = i
						return true
					end
				end
				st.wp_flag = nil
				return false
			end
		end
		st.wp_flag = nil
		return false
	end
end

function action_patrol:hit_callback(obj, amount, local_direction, who, bone_index)
	--[[
	if (bone_index == "from_death_callback") then 
		return 
	end
	if (obj and amount > 0 and who and (IsStalker(who) or IsMonster(who)) and who:alive()) then
		obj:enable_memory_object(who,true)
	end
	--]]
end
----------------------------------------------------------------------------------------------------------------------
-- BINDER
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, ini, scheme, section, storage)
	local manager = object:motivation_action_manager()
	manager:add_evaluator (xr_evaluators_id.stohe_camper_base + 1, this.evaluator_end("camper_end", storage))
	manager:add_evaluator (xr_evaluators_id.stohe_camper_base + 2, this.evaluator_close_combat("camper_close_combat", storage))

	local action = this.action_patrol (object,"action_camper_patrol", storage)
	action:add_precondition	(world_property(stalker_ids.property_alive, true))
	action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 1,			false))
	action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 2,	false))
	action:add_precondition	(world_property(xr_evaluators_id.sidor_wounded_base + 1,	true))
	action:add_precondition (world_property(stalker_ids.property_danger,false))
	action:add_precondition	(world_property(stalker_ids.property_anomaly,false))

	-- Дубляж common_precondition без подбора вещей.
	action:add_precondition (world_property(xr_evaluators_id.stohe_meet_base + 1,false))
	action:add_precondition (world_property(xr_evaluators_id.sidor_wounded_base + 0,  false))
	action:add_precondition (world_property(xr_evaluators_id.abuse_base, false))
	
	if (_G.schemes["facer"]) then
		action:add_precondition(world_property(xrs_facer.evid_facer,false))
		action:add_precondition(world_property(xrs_facer.evid_steal_up_facer,false))
	end
	
	if (_G.schemes["rx_ff"]) then 
		action:add_precondition(world_property(rx_ff.evaid,false))
	end


	action:add_effect (world_property(xr_evaluators_id.stohe_camper_base + 1,				true))
	action:add_effect (world_property(stalker_ids.property_enemy,		false))
	action:add_effect (world_property(xr_evaluators_id.state_mgr + 4, false))
	manager:add_action (xr_actions_id.stohe_camper_base + 1, action)
	xr_logic.subscribe_action_for_events(object, storage, action)

	action = manager:action (xr_actions_id.alife)
	action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 1,			true))

	action = manager:action (stalker_ids.action_gather_items)
	action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 1,			true))

	if (xr_gather_items.actid) then
		action = manager:action (xr_gather_items.actid)
		action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end
	
	if (_G.schemes["corpse_detection"]) then
		action = manager:action (xr_actions_id.corpse_exist)
		action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end
	
	if (_G.schemes["npc_vs_heli"]) then 
		action = manager:action(axr_npc_vs_heli.actid)
		action:add_precondition(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end

	if (_G.schemes["fight_from_cover"]) then 
		action = manager:action(axr_fight_from_cover.actid)
		action:add_precondition(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end
	
	if (_G.schemes["stalker_panic"]) then 
		action = manager:action(axr_stalker_panic.actid)
		action:add_precondition(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end
	
	if (_G.schemes["turn_on_campfire"]) then 
		action = manager:action(axr_turn_on_campfire.actid)
		action:add_precondition(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end
	
	if (_G.schemes["kill_wounded"]) then 
		action = manager:action(xrs_kill_wounded.actid)
		action:add_precondition(world_property(xr_evaluators_id.stohe_camper_base + 1,true))		
	end
	
	action = manager:action (xr_actions_id.wounded_exist)
	action:add_precondition	(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	
	if (xr_danger.actid) then
		action = manager:action(xr_danger.actid)
		action:add_precondition(world_property(xr_evaluators_id.stohe_camper_base + 1,true))
	end

	action = manager:action (stalker_ids.action_combat_planner)
	action:add_precondition (world_property(xr_evaluators_id.stohe_camper_base + 2,	true))
	action:add_effect (world_property(xr_evaluators_id.stohe_camper_base + 2,	false))
	action:add_effect (world_property(xr_evaluators_id.state_mgr + 4, false))
	action:add_effect (world_property(xr_evaluators_id.stohe_camper_base + 1,				true))
end

function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.path_walk = utils.prefix_r_string(ini,section,"path_walk",gulag_name)
	st.path_look = utils.prefix_r_string(ini,section,"path_look",gulag_name)

	if st.path_walk == st.path_look then
		abort("You are trying to set 'path_look' equal to 'path_walk' in section [%s] for npc [%s]", section, npc:name())
	end

	st.sniper = ini:r_bool_ex(section,"sniper",false) 
	st.no_retreat = ini:r_bool_ex(section,"no_retreat") or false
	st.shoot = ini:r_string_ex(section,"shoot") or "always"
	st.sniper_anim = ini:r_string_ex(section,"sniper_anim") or "hide_na"
	if st.sniper == true and st.no_retreat == true then
		_G.abort("ERROR: NPC [%s] Section [%s]. No_retreat not available for SNIPER.", npc:name(), section)
	end

	st.radius = ini:r_float_ex(section,"radius") or 20
	st.suggested_state = {}
	local suggested_state = st.suggested_state
	suggested_state.moving = ini:r_string_ex(section,"def_state_moving")
	suggested_state.moving_fire = ini:r_string_ex(section,"def_state_moving_fire")
	suggested_state.campering = ini:r_string_ex(section,"def_state_campering")
	suggested_state.standing = ini:r_string_ex(section,"def_state_standing") or suggested_state.campering
	suggested_state.campering_fire = ini:r_string_ex(section,"def_state_campering_fire")
	st.scantime_free = ini:r_float_ex(section,"scantime_free") or 60000
	st.attack_sound = ini:r_string_ex(section,"attack_sound") or "fight_attack"

	if st.attack_sound == "false" then
		st.attack_sound = nil
	end

	-- Время забывания врага
	st.idle = ini:r_float_ex(section,"enemy_idle") or 60000
	st.post_enemy_wait = 5000 -- время, которое мы ждем врага, смотря в его последнюю позицию.
	st.enemy_disp = 7/57.2957 -- Угол в пределах которого снайпер ведет поиск потерянного врага.

	st.scandelta = 30
	st.timedelta = 4000
	st.time_scan_delta = st.timedelta/st.scandelta
end

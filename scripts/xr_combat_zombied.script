--[[----------------------------------------------------------------------------------------------------------
Боевая схема зомбированных сталкеров
Чугай Александр
Сделать:
	- анимация поворота
------------------------------------------------------------------------------------------------------------]]
class "evaluator_combat_zombied" ( property_evaluator )
function evaluator_combat_zombied:__init( name, glob_storage ) super ( nil, name )
	self.gst = glob_storage
end

function evaluator_combat_zombied:evaluate()
	local object = self.object
	if not (object:alive()) then 
		return false 
	end
	return object:character_community() == "zombied"
end

class "action_zombie_shoot" ( action_base )
function action_zombie_shoot:__init( name, storage )  super ( nil, name )
	self.st = storage
	self.t  = {}
	self.was_hit = false
	self.hit_reaction_end_time = 0
end

function action_zombie_shoot:initialize()
	action_base.initialize( self )
	local object = self.object
	object:set_path_type(game_object.level_path)
	object:set_detail_path_type(move.line)
	object:set_desired_direction()
	self.last_state = nil
	local be = object:best_enemy()
	if (be) then
		self.enemy_last_seen_pos = be:position()
		self.enemy_last_seen_vid = be:level_vertex_id()
	end
	self.last_vid   = nil
	self.valid_path = false
	self.turn_time  = 0
	self.st.cur_act = 1
	-- xr_sound.set_sound_play(object:id(), "fight_enemy")
end

function action_zombie_shoot:set_state( state, be, pos )
	local t = self.t
	t.look_object = be
	if be then
		t.look_position = self.enemy_last_seen_pos
	else
		t.look_position = pos
	end
	state_mgr.set_state( self.object, state, nil, nil, t, {fast_set = true } )
end

function action_zombie_shoot:execute()
	action_base.execute( self )
	local object = self.object
	local be  = object:best_enemy()
	if not (be) then 
		return 
	end
	local see = object:see( be )
	-- Если видим врага - то запоминаем его позицию и ноду
	if see then
		self.enemy_last_seen_pos = be:position()
		self.enemy_last_seen_vid = be:level_vertex_id()
	end
	local enemy_last_seen_vid = self.enemy_last_seen_vid
	local enemy_last_seen_pos = self.enemy_last_seen_pos
	if self.last_vid ~= enemy_last_seen_vid then
		self.last_vid = enemy_last_seen_vid
		self.valid_path = false
		-- Запоминаем позицию, куда нам надо будет идти
		if (enemy_last_seen_vid >= 4294967295) then
			self.enemy_last_accessible_vid, self.enemy_last_accessible_position  = object:level_vertex_id(), object:position()
		elseif not (object:accessible(enemy_last_seen_vid)) then
			self.enemy_last_accessible_vid, self.enemy_last_accessible_position  = object:accessible_nearest(level.vertex_position(enemy_last_seen_vid), vector())
		else
			self.enemy_last_accessible_vid, self.enemy_last_accessible_position  = enemy_last_seen_vid, enemy_last_seen_pos
		end

	end
	object:set_path_type( game_object.level_path )
	local tg = time_global()
	-- Если мы дальше чем в 3 метрах от позиции, идем в нее.
	if object:position():distance_to_sqr( self.enemy_last_accessible_position ) > 9 then
		if self.valid_path == false then
			self.valid_path = true
			object:set_dest_level_vertex_id(self.enemy_last_accessible_vid)
		end
		if see then
			self:set_state( "raid_fire", be )
		elseif self.was_hit then
			self.was_hit = false
			self.hit_reaction_end_time = tg + 5000
			self:set_state( "raid_fire", nil, enemy_last_seen_pos )
		elseif self.hit_reaction_end_time > tg then
			-- продолжать идти и стрелять в точку, из которой был нанесён хит
		else
			self:set_state( "raid",      nil, enemy_last_seen_pos )
		end
		self.turn_time = 0
	else
		-- Стоим в позиции.
		if see then
			self:set_state( "threat_fire",  be )
			self.turn_time = 0
		else
			-- Время от времени поворачиваем в случайном направлении, типа осматриваемся.
			if self.was_hit then
				self.was_hit = false
				self.turn_time = tg + math.random( 5000, 7000 )
				self:set_state( "threat_na", nil, enemy_last_seen_pos )
			elseif self.turn_time < tg then
				-- printf("[zombied_combat %s] turning", object:name())
				self.turn_time = tg + math.random( 3000, 5000 )
				self:set_state( "threat_na", nil, self:calc_random_direction() )
			end
		end
	end
end

function action_zombie_shoot:calc_random_direction()
	local ang      = math.pi * 2 * math.random()
	local look_pos = vector():set( self.object:position() )
	look_pos.x = look_pos.x + math.cos( ang )
	look_pos.z = look_pos.z + math.sin( ang )
	return look_pos
end

function action_zombie_shoot:finalize()
	action_base.finalize( self )
	self.st.cur_act = nil
end

-- вызывается как для action_zombie_shoot, так и для action_zombie_go_to_danger
function action_zombie_shoot:hit_callback( obj, amount, local_direction, who, bone_index )
	if who == nil then
		return
	end
	if self.st.cur_act == 1 then
		local object = self.object
		local be = object and object:best_enemy()
		-- если получили хит от текущего врага, то мы знаем, где он
		if be and who:id() == be:id() then
			self.enemy_last_seen_pos   = be:position()
			self.enemy_last_seen_vid   = be:level_vertex_id()
			self.was_hit               = true
		end
	end
end

class "action_zombie_go_to_danger" ( action_base )
function action_zombie_go_to_danger:__init( name, storage )  super ( nil, name )
	self.st = storage
	self.t  = {}
	self.was_hit               = false
	self.hit_reaction_end_time = 0
end

function action_zombie_go_to_danger:initialize()
	action_base.initialize( self )
	local object = self.object
	-- object:set_node_evaluator      ()
	-- object:set_path_evaluator      ()
	object:set_desired_direction   ()
	object:set_detail_path_type    ( move.line )
	object:set_path_type           ( game_object.level_path )
	self.last_state  = nil
	self.bdo_id      = nil
	self.bdo_vert_id = nil
	self.last_sent_vert_id = nil
	self.st.cur_act = 2
end

function action_zombie_go_to_danger:set_state( state, be, pos )
	local t = self.t
	t.look_object   = be
	t.look_position = pos
	state_mgr.set_state( self.object, state, nil, nil, t, {fast_set = true })
end

function action_zombie_go_to_danger:execute()
	action_base.execute( self )
	local obj = self.object
	if self.was_hit then
		self.was_hit = false
		self.hit_reaction_end_time = time_global() + 5000
		self:set_state( "raid_fire", nil, self.enemy_last_seen_pos )
	elseif self.hit_reaction_end_time > time_global() then
		-- продолжать идти и стрелять в точку, из которой был нанесён хит
	else
		local bd  = obj:best_danger()
		if not (bd) then
			return
		end
		local bdo = bd:object()
		local bd_pos = bd:position()
		if bdo and bd:type() ~= danger_object.grenade then
			if not self.bdo_id or self.bdo_id ~= bdo:id() then
				self.bdo_id      = bdo:id()
				self.bdo_vert_id = bdo:level_vertex_id()
			end
			local bdo_vert_id = self.bdo_vert_id
			if bdo_vert_id ~= self.last_sent_vert_id then
				self.last_sent_vert_id = bdo_vert_id
				self.bdo_vert_id = utils.send_to_nearest_accessible_vertex(obj, bdo_vert_id )
			end
			self:set_state( "raid", nil, bd_pos)
		else
			self:set_state( "threat_na",  nil, bd_pos)
		end
	end
end

function action_zombie_go_to_danger:finalize()
	action_base.finalize( self )
	self.st.cur_act = nil
end

-- вызывается как для action_zombie_shoot, так и для action_zombie_go_to_danger
function action_zombie_go_to_danger:hit_callback( obj, amount, local_direction, who, bone_index )
	if who == nil then
		return
	end
	if self.st.cur_act == 2 then
		local bd  = self.object:best_danger()
		if bd then
			local bdo = bd:object()
			if bdo ~= nil and
				 (bd:type() == danger_object.attacked or amount > 0)
			then
				self.enemy_last_seen_pos   = bdo:position()
				self.enemy_last_seen_vid   = bdo:level_vertex_id()
				self.was_hit               = true
			end
		end
	end
end

function add_to_binder(npc,ini,scheme,section,st,temp)
	local manager = npc:motivation_action_manager()
	local xr_actions_id_combat_zombied_base = xr_actions_id.combat_zombied_base
	local xr_evaluators_id_combat_zombied_base = xr_evaluators_id.combat_zombied_base
	local xr_evaluators_id_state_mgr = xr_evaluators_id.state_mgr
	local stalker_ids_property_danger = stalker_ids.property_danger
	local stalker_ids_property_alive = stalker_ids.property_alive
	local stalker_ids_property_enemy = stalker_ids.property_enemy
	manager:add_evaluator( xr_evaluators_id_combat_zombied_base, evaluator_combat_zombied( "combat_zombied", db.storage[npc:id()] ) )

	local action = action_zombie_shoot( "action_zombie_shoot", st )
	action:add_precondition( world_property(stalker_ids_property_alive,           true  ) )
	action:add_precondition( world_property( xr_evaluators_id_combat_zombied_base, true  ) )
	action:add_precondition( world_property( xr_evaluators_id.script_combat,       true  ) )
	action:add_effect( world_property(stalker_ids_property_enemy,           false ) )
	action:add_effect(world_property(xr_evaluators_id_state_mgr + 4, false))
	manager:add_action(xr_actions_id_combat_zombied_base, action )

	xr_logic.subscribe_action_for_events( npc, st, action )

	action = action_zombie_go_to_danger( "action_zombie_go_to_danger", st )
	action:add_precondition( world_property(stalker_ids_property_alive,           true  ) )
	action:add_precondition( world_property( xr_evaluators_id_combat_zombied_base, true  ) )
	action:add_precondition( world_property(stalker_ids_property_enemy,           false ) )
	action:add_precondition( world_property(stalker_ids_property_danger,          true  ) )
	action:add_effect( world_property(stalker_ids_property_danger,          false ) )
	action:add_effect(world_property(xr_evaluators_id_state_mgr + 4, false))
	manager:add_action(xr_actions_id_combat_zombied_base + 1, action )

	xr_logic.subscribe_action_for_events( npc, st, action )
end

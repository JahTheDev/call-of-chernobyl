-----------
-- modified by Alundaio

phantom_registry = {}

-----------------------------
-- DynamicPhantom
-----------------------------
class "DynamicPhantom" (object_binder)
function DynamicPhantom:__init(obj) super(obj)
	phantom_registry[obj:section()] = phantom_registry[obj:section()] and phantom_registry[obj:section()] + 1 or 1
end
function DynamicPhantom:net_spawn(sobject)
	if not object_binder.net_spawn(self, sobject) then
		return false
	end
	return true
end
function DynamicPhantom:net_destroy()
	phantom_registry[self.object:section()] = phantom_registry[self.object:section()] and phantom_registry[self.object:section()] - 1 or 0
	object_binder.net_destroy(self)
end
function bind_phantom(obj)
	obj:bind_object(DynamicPhantom(obj))
end 

--------------------------------------------------------------------------------------

function spawn_dynamic_phantom(sec,pos,lvid,enemy)
	if (level.spawn_item) then
		--alun_utils.debug_write("spawn_dynamic_phantom")
		level.spawn_item(sec,pos,lvid,65535,false)
	end
end

function dynamic_phantom_count(sec)
	return phantom_registry[sec] or 0
end

local function monster_on_update(npc,st)
	if not (npc and npc:alive()) then 
		return 
	end
	local tg = time_global()
	if (st.__phantom_check and tg < st.__phantom_check) then
		return 
	end
	st.__phantom_check = tg + 5000
	
	if (has_alife_info("bar_deactivate_radar_done")) then 
		return 
	end 
	
	local phantom_section = alun_utils.read_from_ini(nil,npc:section(),"spawn_phantom","string")
	if not (phantom_section) then
		return 
	end
	
	local can_spawn = sr_psy_antenna.psy_antenna and sr_psy_antenna.psy_antenna.global_state == 1 or alun_utils.read_from_ini(nil,npc:section(),"can_spawn_phantom","bool")
	if not (can_spawn) then 
		return
	end 
	
	if not (xr_combat_ignore.fighting_with_actor_npcs[npc:id()]) then 
		return false 
	end
	
	if (db.actor:position():distance_to_sqr(npc:position()) > 900) then 
		return false 
	end
	
	local sec = alun_utils.read_from_ini(nil,npc:section(),"spawn_phantom","string")
	if (phantom_manager.dynamic_phantom_count(sec) >= 4) then 
		return false
	end
	
	if (st.__phantom_check2 and tg < st.__phantom_check2) then
		return 
	end
	st.__phantom_check2 = tg + 10000
	
	phantom_manager.spawn_dynamic_phantom(sec,npc:position(),npc:level_vertex_id(),npc:get_enemy())
end 

function on_game_start()
	if (level.spawn_item) then
		RegisterScriptCallback("monster_on_update",monster_on_update)
	end
end 

---------------------------------------------------------------------------
-- LEGACY
class "PhantomManager"
function PhantomManager:__init()
	self.phantom_count		= 0;
end
g_PhantomManager			= PhantomManager();

function PhantomManager:add_phantom		()
	self.phantom_count		= self.phantom_count + 1;
end
function PhantomManager:remove_phantom	()
	self.phantom_count		= self.phantom_count - 1;
end
function PhantomManager:spawn_phantom	(pos)
	level.spawn_phantom		(pos);
end

class "Phantom"		(object_binder)
function Phantom:__init(obj) super(obj)
	g_PhantomManager:add_phantom();
end
function Phantom:net_destroy()
	g_PhantomManager:remove_phantom();
end
function bind(obj)
	obj:bind_object	(Phantom(obj))
end

function spawn_phantom		(pos)
	g_PhantomManager:spawn_phantom(pos);
end
function phantom_count		()
	return g_PhantomManager.phantom_count;
end



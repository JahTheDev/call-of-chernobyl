--[[
Copyright (C) 2014 Alundaio
This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License

Callback and module manager for easy plug-in based script management
by Alundaio
--]]

local alife, game_graph, pairs, marshal, level = alife, game_graph, pairs, _G.marshal, level
local last_save

-------------------------------------------------------------------------------------------------
-- Use Xetrill's lua.jit dll and marshal library for saving persistent data (like xr_logic pstor)
-- marshal library can encode tables, functions, strings and numbers to easily allow persistent data storage to file
-- This is used for db.storage[id].pstor and coc_treasure_manager.script if enabled

USE_MARSHAL = false -- marshal ~= nil
m_data = {}
-------------------------------------------------------------------------------------------------

REMOVE_ME_LC			= nil 			-- Used by custom jump level command in xrs_debug_tools and faction select
------------------------------
LOUD_SOUND_THRESHOLD 	= 35			-- Used for actor targetting by sim_board.script
MAX_SQUADS 				= 256			-- Non-storied Squads above this count will randomly be removed on game load
------------------------------

config = alun_utils.cfg_file(alun_utils.fspath("$game_data$").."axr_options.ini")

-- Valid Callbacks (named intercepts to avoid namespace conflicts)
local intercepts = {
	-- _g.script

	-- ui_main_menu.script
	main_menu_on_keyboard		= {},
	main_menu_on_init			= {},
	main_menu_on_init_callbacks	= {},
	main_menu_on_quit			= {},

	-- ui_mm_opt_main.script
	opt_menu_on_init			= {},
	opt_menu_on_accept			= {},
	opt_menu_on_set_values		= {},

	-- xr_motivator.script
	npc_on_use 					= {},
	npc_on_item_take 			= {},
	npc_on_item_drop 			= {},
	npc_on_net_spawn			= {},
	npc_on_net_destroy 			= {},
	npc_on_update				= {},
	npc_on_weapon_no_ammo 		= {},
	npc_on_weapon_sight			= {},
	npc_on_weapon_unsight		= {},
	npc_on_hit_callback			= {},
	npc_on_death_callback		= {},
	npc_on_fighting_actor		= {},
	npc_add_precondition		= {},
	npc_on_item_take_from_box	= {},
	npc_on_weapon_state_change	= {},

	-- state_mgr_weapon.script
	npc_on_weapon_strapped		= {},
	npc_on_weapon_unstrapped	= {},
	npc_on_weapon_drop			= {},

	-- xr_hear.script
	npc_on_hear_callback		= {},

	-- se_stalker.script
	se_stalker_on_spawn			= {},

	-- se_actor.script
	se_actor_on_register		= {},
	se_actor_on_unregister		= {},
	se_actor_on_STATE_Write		= {},
	se_actor_on_STATE_Read		= {},

	-- xr_corpse_detection.script
	npc_on_get_all_from_corpse 	= {},

	-- sim_board.script
	squad_on_update				= {},
	squad_on_npc_creation		= {},
	squad_on_add_npc			= {},
	squad_can_switch_offline	= {},
	squad_on_unregister			= {},

	-- sim_squad_scripted.script
	squad_assign_new_target		= {},
	squad_can_help_actor		= {},
	squad_on_npc_death			= {},

	-- xr_logic.script
	on_pstor_load_all			= {},
	set_generic_scheme			= {},
	scheme_reset				= {},
	scheme_disable				= {},
	scheme_deactivate			= {},

	-- bind_stalker.script
	on_game_load				= {},
	on_game_end					= {},
	actor_on_update				= {},
	actor_on_weapon_no_ammo		= {},
	actor_on_weapon_zoom_in		= {},
	actor_on_weapon_zoom_out	= {},
	actor_on_item_take			= {},
	actor_on_item_take_from_box = {},
	actor_on_item_drop			= {},
	actor_on_item_use			= {},
	actor_on_trade				= {},
	actor_on_save				= {},
	actor_on_load				= {},
	actor_on_init				= {},
	actor_on_torch_enabled		= {},
	actor_on_torch_disabled		= {},
	actor_on_info_callback		= {},
	actor_on_leave_dialog		= {},

	-- bind_monster.script
	monster_on_update				= {},
	monster_on_hit_callback			= {},
	monster_on_net_spawn			= {},
	monster_on_death_callback		= {},
	monster_on_actor_use_callback   = {},

	-- bind_physic_object
	physic_object_on_hit_callback 	= {},
	physic_object_on_use_callback 	= {},

	-- Custom saving feature (uses Xetril's lua.jit dll)
	on_level_changing				= {},
	save_state						= {},
	load_state						= {}
}

-----------------------------------------------------------
-- Global Callback Register
-- param 1 - name as type<string> (ie. intercepts[name])
-- param 2 - function to execute as type<function> or type<table>
-----------------------------------------------------------
function callback_register(name,func)
	if not (func) then
		return
	end
	if (intercepts[name]) then
		table.insert(intercepts[name],func)
	end
end

function callback_unregister(name,func)
	if not (intercepts[name]) then
		return
	end

	local index
	for i=#intercepts[name],1,-1 do
		if (intercepts[name][i] == func) then
			index = i
			break
		end
	end

	if (index) then
		table.remove(intercepts[name],index)
	end
end

--------------------------------------------
-- Displays message on middle-top of screen for n amount of milliseconds
-- param 1 - Message as string
-- param 2 - Milliseconds as number
--------------------------------------------
local ShowMessageTime
function _G.SetHudMsg(msg,n)
	msg = tostring(msg)
	local hud = get_hud()
	hud:AddCustomStatic("not_enough_money_mine", true)
	hud:GetCustomStatic("not_enough_money_mine"):wnd():TextControl():SetTextST(msg)
	ShowMessageTime = time_global() + n*1000
end

--------------------------------------------------------------------------------------------
-- 								Delayed Event Queue
--
-- Events must have a unique id. Such as object id or another identifier unique to the occasion.
-- Action id must be unique to the specific Event. This allows a single event to have many queued
-- actions waiting to happen.
--
-- Returning true will remove the queued action. Returning false will execute the action continuously.
-- This allows for events to wait for a specific occurrence, such as triggering after a certain amount of
-- time only when object is offline
--
-- param 1 - Event ID as type<any>
-- param 2 - Action ID as type<any>
-- param 3 - Timer in seconds as type<number>
-- param 4 - Function to execute as type<function>
-- extra params are passed to executing function as table as param 1

-- see on_game_load or state_mgr_animation.script for example uses
-- All queued actions are executed on game save. If using marshal, then queue persists through saves
----------------------------------------------------------------------------------------------
local ev_queue = {}
function _G.create_delayed_event(ev_id,act_id,timer,f,...)
	if not (ev_queue[ev_id]) then
		ev_queue[ev_id] = {}
		ev_queue[ev_id].size = 0
	end

	if not (ev_queue[ev_id][act_id]) then
		ev_queue[ev_id][act_id] = {}
		ev_queue[ev_id][act_id].game_time = game.get_game_time()
		ev_queue[ev_id][act_id].timer = timer
		ev_queue[ev_id][act_id].f = f
		ev_queue[ev_id][act_id].p = {...}
		ev_queue[ev_id].size = ev_queue[ev_id].size + 1
	end
end

--------------------------------------------------------------------------------------------------------------------
-- Private functions
--------------------------------------------------------------------------------------------------------------------
local function remove_squad(p)
	local squad = p[1] and alife():object(p[1])
	if not (squad) then
		return true
	end
	
	SIMBOARD:assign_squad_to_smart(squad, nil)
	squad:remove_squad()
	return true
end

local function remove_non_story_squads(p)
	local sor = story_objects.get_story_objects_registry()
	local board = SIMBOARD
	local gg = game_graph()
	local se_actor = alife():actor()
	
	for id,squad in pairs(board.squads) do
		if (squad and squad.m_game_vertex_id and sor:get_story_id(id) == nil) then
			-- simulation_objects.sim_dist_to(se_actor,squad) > 2000
			if (gg:vertex(db.actor:game_vertex_id()):level_id() ~= gg:vertex(squad.m_game_vertex_id):level_id()) then
				create_delayed_event(squad.id,"remove_squad",math.random(1,220),remove_squad,squad.id)
				p[1] = p[1] - 1
			end
		end

		if (p[1] < MAX_SQUADS) then
			return true
		end
	end
	return true
end

local function event_queue(force)
	local gt
	for event_id,actions in pairs(ev_queue) do

		for action_id,act in pairs(actions) do
			--alun_utils.debug_write(alun_utils.sr("event_queue: event_id=%s action_id=%s",event_id,action_id))
			if (action_id ~= "size") then
				gt = act.game_time
				if (gt == nil) or (force) or (game.get_game_time():diffSec(gt) >= act.timer) then
					if (act.f(act.p) == true) then
						ev_queue[event_id][action_id] = nil
						ev_queue[event_id].size = ev_queue[event_id].size - 1
					end
				end
			end
		end

		if (ev_queue[event_id].size == 0) then
			ev_queue[event_id] = nil
		end
	end
end

--[[
									ON GAME START

	Register modules here. Their on_game_start functions should register callbacks they need.
--]]
function on_game_start()
	-- CoP
	if (xrs_dyn_music) then xrs_dyn_music.on_game_start() end 
	
	-- Call of Chernobyl specific
	if (coc_treasure_manager) then coc_treasure_manager.on_game_start() end
	if (ui_mm_faction_select) then ui_mm_faction_select.on_game_start() end

	-- Alundaio Extensions
	if (xrs_rnd_npc_loadout) then xrs_rnd_npc_loadout.on_game_start() end
	--if (axr_dynamic_spawn) then axr_dynamic_spawn.on_game_start() end
	if (itms_manager) then itms_manager.on_game_start() end
	if (xr_statistic.on_game_start) then xr_statistic.on_game_start() end
	if (m_mines) then m_mines.on_game_start() end
	if (axr_task_manager) then axr_task_manager.on_game_start() end

	-- AI Tweaks
	if (xr_danger and xr_danger.on_game_start) then xr_danger.on_game_start() end
	if (xr_gather_items and xr_gather_items.on_game_start) then xr_gather_items.on_game_start() end
	if (xr_corpse_detection.on_game_start) then xr_corpse_detection.on_game_start() end
	if (xr_combat_ignore and xr_combat_ignore.on_game_start) then xr_combat_ignore.on_game_start() end
	if (ai_tweaks) then ai_tweaks.on_game_start() end
	--if (xr_visual) then xr_visual.on_game_start() end
	if (xr_eat_medkit) then xr_eat_medkit.on_game_start() end
	if (axr_trade_manager) then axr_trade_manager.on_game_start() end

	-- SCHEMES
	if (axr_beh) then axr_beh.on_game_start() end
	if (axr_companions) then axr_companions.on_game_start() end
	if (xrs_facer) then xrs_facer.on_game_start() end
	if (xrs_kill_wounded) then xrs_kill_wounded.on_game_start() end
	if (rx_gl) then rx_gl.on_game_start() end
	if (rx_ff) then rx_ff.on_game_start() end
	if (xr_campfire_point) then xr_campfire_point.on_game_start() end
	if (axr_turn_on_campfire) then axr_turn_on_campfire.on_game_start() end
	if (axr_new_combat) then axr_new_combat.on_game_start() end
	if (axr_radio_in_heli) then axr_radio_in_heli.on_game_start() end
end

-------------------
-- se_actor_on_register()
-- Notes: This runs soon after alife simulator is started.
-------------------
function se_actor_on_register(actor)
	--alun_utils.debug_write("se_actor_on_register")
	for i=1, #intercepts.se_actor_on_register do
		intercepts.se_actor_on_register[i](actor)
	end
end

-------------------
-- se_actor_on_unregister()
-------------------
function se_actor_on_unregister(actor)
	--alun_utils.debug_write("se_actor_on_unregister")
	for i=1, #intercepts.se_actor_on_unregister do
		intercepts.se_actor_on_unregister[i](actor)
	end
end

-------------------
-- se_actor_on_STATE_Write(se_actor,packet)
-------------------
function se_actor_on_STATE_Write(se_actor,packet)
	--alun_utils.debug_write("se_actor_on_STATE_Write")
end

-------------------
-- se_actor_on_STATE_Read(se_actor,packet)
-------------------
function se_actor_on_STATE_Read(se_actor,packet,size)
	--alun_utils.debug_write("se_actor_on_STATE_Read")
end

-------------------
-- on_game_load() ;Actor Net Spawn
-------------------
function on_game_load()
	math.randomseed(time_global())
	
	--alun_utils.debug_write("on_game_load")
	for i=1, #intercepts.on_game_load do
		intercepts.on_game_load[i]()
	end

	local count = 0
	local sor = story_objects.get_story_objects_registry()
	local board = SIMBOARD
	local gg = game_graph()
	for id,squad in pairs(board.squads) do
		if (squad and squad.m_game_vertex_id and sor:get_story_id(id) == nil) then
			if (gg:vertex(db.actor:game_vertex_id()):level_id() ~= gg:vertex(squad.m_game_vertex_id):level_id()) then
				count = count + 1
			end
		end
	end

	if (count > MAX_SQUADS) then
		create_delayed_event(0,"remove_non_story_squads",60,remove_non_story_squads,count)
	end
	
	--[[
	count = 0
	local sim = alife()
	for i=1,65534 do
		if (sim:object(i)) then
			count = count + 1
		end
	end
	alun_utils.printf("axr_main.on_game_load: There are %s object ids in use.",count)
	--]]

end

-------------------
-- on_game_end() ;Actor Net Destroy
-------------------
function on_game_end()
	--alun_utils.debug_write("on_game_end")
	for i=1, #intercepts.on_game_end do
		intercepts.on_game_end[i]()
	end
end

---------------------
-- on_pstor_load_all(obj,packet)
---------------------
function on_pstor_load_all(obj,packet)
	--alun_utils.debug_write("on_pstor_load_all")
	for i=1, #intercepts.on_pstor_load_all do
		intercepts.on_pstor_load_all[i](obj,packet)
	end
end

-------------------
-- actor_on_init()
-------------------
function actor_on_init(se_actor)
	--alun_utils.debug_write("actor_on_init")
	for i=1, #intercepts.actor_on_init do
		intercepts.actor_on_init[i](se_actor)
	end
end

-------------------
-- actor_on_info_callback(npc,info_id)
-------------------
function actor_on_info_callback(npc,info_id)
	--alun_utils.debug_write("actor_on_info_callback "..tostring(info_id))
	for i=1, #intercepts.actor_on_info_callback do
		intercepts.actor_on_info_callback[i](npc,info_id)
	end
end

-------------------
-- actor_on_update()
-------------------
local actor_sound_incr
local actor_reload
local actor_scope
local actor_talking
actor_light = nil
function actor_on_update(se_actor,delta)
	--alun_utils.debug_write("actor_on_update")
	for i=1, #intercepts.actor_on_update do
		if (intercepts.actor_on_update[i]) then
			intercepts.actor_on_update[i](se_actor,delta)
		end
	end

	local tg = time_global()
	
	-- evaluate event queue
	event_queue()

	-- Check HudMsg
	if (ShowMessageTime) then
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("not_enough_money_mine")
		if custom_static ~= nil and tg > ShowMessageTime then
			hud:RemoveCustomStatic("not_enough_money_mine")
			ShowMessageTime = nil
		end
	end

	if not upd_dtimer then
		upd_dtimer = tg + 250
	end

	if (tg < upd_dtimer) then
		return
	end
	upd_dtimer = tg + 250

	if (db.actor:is_talking() and not actor_talking) then 
		actor_talking = true
	elseif (db.actor:is_talking() ~= true and actor_talking) then 
		actor_talking = nil
		for i=1, #intercepts.actor_on_leave_dialog do
			intercepts.actor_on_leave_dialog[i](se_actor)
		end
	end
	
	-- Are-wide sound decrement
	actor_sound_incr = actor_sound_incr and actor_sound_incr - 0.25
	if (actor_sound_incr and actor_sound_incr < 0) then
		actor_sound_incr = 0
	end

	if (db.storage[0].loud and tg > db.storage[0].loud) then
		db.storage[0].loud = nil
		db.storage[0].loud_gvid = nil
		db.storage[0].loud_lvid = nil
		--if (actor_sound_incr and actor_sound_incr < LOUD_SOUND_THRESHOLD) then
			--alun_utils.printf("Actor is quiet")
		--end
	end

	local wpn = db.actor:active_item()
	if (wpn) then
		if (alun_utils.item_is_fa(wpn)) then
			local inmag = wpn:get_ammo_in_magazine()
			if (inmag == 0) then
				if not (actor_reload) then
					actor_reload = true
					actor_on_weapon_no_ammo(wpn)
				end
			else
				actor_reload = nil
			end

			-- Area-wide sound threshold (Check sim_board how it's used)
			local se_obj = alife():object(wpn:id())
			local data = se_obj and stpk_utils.get_weapon_data(se_obj)
			if (data.weapon_state == 5) then

				if (alun_utils.addon_attached(wpn,"sl",data.addon_flags)) then
					actor_sound_incr = actor_sound_incr and actor_sound_incr + 1 or 1
				else
					actor_sound_incr = actor_sound_incr and actor_sound_incr + 2 or 2
				end

				if (actor_sound_incr > LOUD_SOUND_THRESHOLD) then
					actor_sound_incr = LOUD_SOUND_THRESHOLD
					--if not (db.storage[0].loud) then
						--alun_utils.printf("Actor is being loud")
					--end
					db.storage[0].loud = tg + 50000		-- 50 seconds
					db.storage[0].loud_gvid = db.actor:game_vertex_id()
					db.storage[0].loud_lvid = db.actor:level_vertex_id()
				end
			end
		end

		if (wpn:section() == "wpn_binoc" or alun_utils.addon_attached(wpn,"sc")) then
			if (device().fov < 50) then
				if not (actor_scope) then
					actor_scope = true
					actor_on_weapon_zoom_in(wpn)
				end
			else
				if (actor_scope) then
					actor_scope = nil
					actor_on_weapon_zoom_out(wpn)
				end
			end
		else
			if (actor_scope) then
				actor_scope = nil
				actor_on_weapon_zoom_out(wpn)
			end
		end
	end

	local torch = db.actor:object("device_torch")
	if (torch and not actor_light and torch:torch_enabled()) then
		actor_light = true
		actor_on_torch_enabled()
	elseif (torch and not torch:torch_enabled()) then
		if (actor_light) then
			actor_light = false
			actor_on_torch_disabled()
		end
	end
end

-------------------
-- actor_on_weapon_no_ammo(wpn)
-------------------
function actor_on_weapon_no_ammo(wpn)
	for i=1, #intercepts.actor_on_weapon_no_ammo do
		intercepts.actor_on_weapon_no_ammo[i](wpn)
	end
end

-------------------
-- actor_on_weapon_zoom_in(wpn)
-------------------
function actor_on_weapon_zoom_in(wpn)
	for i=1, #intercepts.actor_on_weapon_zoom_in do
		intercepts.actor_on_weapon_zoom_in[i](wpn)
	end
end

-------------------
-- actor_on_weapon_zoom_out(wpn)
-------------------
function actor_on_weapon_zoom_out(wpn)
	for i=1, #intercepts.actor_on_weapon_zoom_out do
		intercepts.actor_on_weapon_zoom_out[i](wpn)
	end
end

-------------------
-- actor_on_torch_enabled()
-------------------
function actor_on_torch_enabled()
	for i=1, #intercepts.actor_on_torch_enabled do
		intercepts.actor_on_torch_enabled[i]()
	end
end

-------------------
-- actor_on_torch_disabled()
-------------------
function actor_on_torch_disabled()
	for i=1, #intercepts.actor_on_torch_disabled do
		intercepts.actor_on_torch_disabled[i]()
	end
end

-------------------
-- actor_on_item_take(item)
-------------------
function actor_on_item_take(item)
	for i=1, #intercepts.actor_on_item_take do
		intercepts.actor_on_item_take[i](item)
	end
end

-------------------
-- actor_on_item_take_from_box(box,item)
-------------------
function actor_on_item_take_from_box(box,item)
	for i=1, #intercepts.actor_on_item_take_from_box do
		intercepts.actor_on_item_take_from_box[i](box,item)
	end
end

-------------------
-- actor_on_item_drop(item)
-------------------
function actor_on_item_drop(item)
	for i=1, #intercepts.actor_on_item_drop do
		intercepts.actor_on_item_drop[i](item)
	end
end

-------------------
-- actor_on_item_use(item)
-------------------
function actor_on_item_use(item)
	for i=1, #intercepts.actor_on_item_use do
		intercepts.actor_on_item_use[i](item)
	end
end

-------------------
-- actor_on_trade(item)
-------------------
function actor_on_trade(item,sell_bye,money)
	for i=1, #intercepts.actor_on_trade do
		intercepts.actor_on_trade[i](item,sell_bye,money)
	end
end

-------------------
-- actor_on_save(bind_stalker,packet)
-------------------
function actor_on_save(binder,packet)
	local sim,gg = alife(),game_graph()
	local actor_gv = sim and gg:vertex(sim:actor().m_game_vertex_id)
	
	if (actor_gv and actor_gv:level_id() ~= sim:level_id()) then
		alun_utils.printf("actor changing level")
		if (REMOVE_ME_LC) then
			local sim = alife()
			local se_obj = sim:object(REMOVE_ME_LC)
			if (se_obj) then
				alun_utils.printf("removing temp level_changer %s",se_obj:name())
				sim:release(se_obj,true)
			end
		end
		
		for i=1,#intercepts.on_level_changing do 
			intercepts.on_level_changing[i]()
		end
	end
	
	if (USE_MARSHAL) then
		-- save last level id
		--packet:w_u16(actor_gv and actor_gv:level_id() or 65535)
	
		local path = alun_utils.fspath("$game_saves$")..(last_save or alun_utils.is_level_changing() and user_name():lower() .. " - autosave" or user_name():lower().." - quicksave")..".dat"
		last_save = nil

		local savegame = io.open(path,"wb+")
		if (savegame) then
			packet:w_stringZ(path)

			for i=1, #intercepts.save_state do
				intercepts.save_state[i](m_data)
			end

			for id,t in pairs(db.storage) do
				if (t and type(t) == "table") then
					if (t.pstor) then
						if not (m_data.pstor_all) then
							m_data.pstor_all = {}
						end
						m_data.pstor_all[id] = t.pstor
					end
				end
			end

			local data = marshal.encode(m_data)
			if (data) then
				alun_utils.printf("axr_main: saving custom data %s",path)
				savegame:write(data)
				savegame:close()
			end
		end
		
		return
	end
	if (coc_treasure_manager) then
		coc_treasure_manager.save(packet)
	end
	
	-- save last level id
	--packet:w_u16(actor_gv and actor_gv:level_id() or 65535)
end

-------------------
-- actor_on_load(bind_stalker,packet)
-------------------
function actor_on_load(binder,packet)
	if (USE_MARSHAL) then
	--	last_level_id = packet:r_u16()
		
		local path = packet:r_stringZ()
		if (not path or path:sub(-4) ~= ".dat") then
			return
		end

		local savegame = io.open(path,"rb")
		if not (savegame) then
			return
		end

		local data = savegame:read("*all")
		savegame:close()

		if not (data) then
			return
		end

		m_data = marshal.decode(data) or m_data

		alun_utils.printf("axr_main: loading custom data %s", path)

		for i=1, #intercepts.load_state do
			intercepts.load_state[i](m_data)
		end

		return
	end
	if (coc_treasure_manager) then
		coc_treasure_manager.load(packet)
	end
	--last_level_id = packet:r_u16()
end

-------------------
-- se_stalker_on_spawn(se_npc)
-------------------
function se_stalker_on_spawn(se_npc)
	--alun_utils.debug_write("se_stalker_on_spawn"..tostring(se_npc and se_npc:name()))
	for i=1, #intercepts.se_stalker_on_spawn do
		intercepts.se_stalker_on_spawn[i](se_npc)
	end
end

-------------------
-- npc_on_use(npc,who)
-------------------
function npc_on_use(npc,who)
	for i=1, #intercepts.npc_on_use do
		intercepts.npc_on_use[i](npc,who)
	end
end

-------------------
-- npc_on_item_take(npc,item)
-------------------
function npc_on_item_take(npc,item)
	--alun_utils.debug_write("npc_on_item_take")
	for i=1, #intercepts.npc_on_item_take do
		intercepts.npc_on_item_take[i](npc,item)
	end
end

-------------------
-- npc_on_item_drop(npc,item)
-------------------
function npc_on_item_drop(npc,item)
	--alun_utils.debug_write("npc_on_item_drop")
	for i=1, #intercepts.npc_on_item_drop do
		intercepts.npc_on_item_drop[i](npc,item)
	end
end

-------------------
-- npc_on_net_spawn(npc,se_npc)
-------------------
function npc_on_net_spawn(npc,se_npc)
	--alun_utils.debug_write("npc_on_net_spawn")
	for i=1, #intercepts.npc_on_net_spawn do
		intercepts.npc_on_net_spawn[i](npc,se_npc)
	end
end

-------------------
-- npc_on_net_destroy(npc)
-------------------
function npc_on_net_destroy(npc)
	--alun_utils.debug_write("npc_on_net_destroy")
	for i=1, #intercepts.npc_on_net_destroy do
		intercepts.npc_on_net_destroy[i](npc)
	end
end

-------------------
-- npc_on_update(npc,st)
-------------------
function npc_on_update(npc,st)
	--alun_utils.debug_write("npc_on_update")
	for i=1, #intercepts.npc_on_update do
		intercepts.npc_on_update[i](npc,st)
	end

	if (npc:alive()) then
		local wpn = npc:best_weapon()
		if (wpn and alun_utils.item_is_fa(wpn)) then
			local inmag = wpn:get_ammo_in_magazine()
			if (inmag == 0) then
				if not (st.weapon_reload) then
					st.weapon_reload = true
					npc_on_weapon_no_ammo(npc,wpn,st)
				end
			else
				st.weapon_reload = nil
			end

			local sight_type = npc:sight_params().m_sight_type
			if (sight_type) and (sight_type == 4 or sight_type == 9 or sight_type == 10) then
				if not (st.sight_type) then
					npc_on_weapon_sight(npc,wpn,st,sight_type)
					st.sight_type = sight_type
				end
			else
				if (st.sight_type) then
					st.sight_type = nil
					npc_on_weapon_unsight(npc,wpn,st,sight_type)
				end
			end

			--[[
			local sobj = alife():object(wpn:id())
			local data = stpk_utils.get_weapon_data(sobj)

			if (st.weapon_state ~= data.weapon_state) then
				npc_on_weapon_state_change(npc,wpn,st,data.weapon_state)
				st.weapon_state = data.weapon_state
			end
			--]]
		end
	end
end

------------------
-- npc_on_weapon_state_change(npc,weapon,storage)
-------------------
function npc_on_weapon_state_change(npc,wpn,st,state)
	--alun_utils.debug_write("npc_on_weapon_state_change")
	for i=1, #intercepts.npc_on_weapon_state_change do
		intercepts.npc_on_weapon_state_change[i](npc,wpn,st,state)
	end
end

------------------
-- npc_on_weapon_no_ammo(npc,weapon,storage)
-------------------
function npc_on_weapon_no_ammo(npc,wpn,st)
	for i=1, #intercepts.npc_on_weapon_no_ammo do
		intercepts.npc_on_weapon_no_ammo[i](npc,wpn,st)
	end
end

------------------
-- npc_on_weapon_sight(npc,weapon,storage)
-------------------
function npc_on_weapon_sight(npc,wpn,st,sight_type)
	for i=1, #intercepts.npc_on_weapon_sight do
		intercepts.npc_on_weapon_sight[i](npc,wpn,st,sight_type)
	end
end

------------------
-- npc_on_weapon_unsight(npc,weapon,storage)
-------------------
function npc_on_weapon_unsight(npc,wpn,st,sight_type)
	for i=1, #intercepts.npc_on_weapon_unsight do
		intercepts.npc_on_weapon_unsight[i](npc,wpn,st,sight_type)
	end
end


-------------------
-- npc_on_weapon_strapped(npc,weapon)
-------------------
function npc_on_weapon_strapped(npc,wpn)
	for i=1, #intercepts.npc_on_weapon_strapped do
		intercepts.npc_on_weapon_strapped[i](npc,wpn)
	end
end

-------------------
-- npc_on_weapon_unstrapped(npc,weapon)
-------------------
function npc_on_weapon_unstrapped(npc,wpn)
	for i=1, #intercepts.npc_on_weapon_unstrapped do
		intercepts.npc_on_weapon_unstrapped[i](npc,wpn)
	end
end

-------------------
-- npc_on_weapon_drop(npc,weapon)
-------------------
function npc_on_weapon_drop(npc,wpn)
	for i=1, #intercepts.npc_on_weapon_drop do
		intercepts.npc_on_weapon_drop[i](npc,wpn)
	end
end

-------------------
-- npc_on_weapon_fire(npc,weapon)
-------------------
function npc_on_weapon_fire(npc,wpn)
	for i=1, #intercepts.npc_on_weapon_fire do
		intercepts.npc_on_weapon_fire[i](npc,wpn)
	end
end

-------------------
-- npc_add_precondition(action)
-------------------
function npc_add_precondition(action)
	--alun_utils.debug_write("npc_add_precondition")
	for i=1, #intercepts.npc_add_precondition do
		intercepts.npc_add_precondition[i](action)
	end
end

-------------------
-- npc_on_hear_callback(obj,who_id,s_type,sound_dist,sound_power,sound_position)
-------------------
function npc_on_hear_callback(obj,who_id,s_type,sound_dist,sound_power,sound_position)
	--alun_utils.debug_write("npc_on_hear_callback")
	for i=1, #intercepts.npc_on_hear_callback do
		intercepts.npc_on_hear_callback[i](obj,who_id,s_type,sound_dist,sound_power,sound_position)
	end
end

-------------------
-- npc_on_hit_callback(npc,amount,local_direction,who,bone_index)
-------------------
function npc_on_hit_callback(npc,amount,local_direction,who,bone_index)
	--alun_utils.debug_write("npc_on_hit_callback")
	for i=1, #intercepts.npc_on_hit_callback do
		intercepts.npc_on_hit_callback[i](npc,amount,local_direction,who,bone_index)
	end
end

-------------------
-- npc_on_death_callback(npc,who)
-------------------
function npc_on_death_callback(npc,who)
	--alun_utils.printf("death_callback for %s killed by %s",npc:name(),who:name())
	--alun_utils.debug_write("npc_on_death_callback")
	for i=1, #intercepts.npc_on_death_callback do
		intercepts.npc_on_death_callback[i](npc,who)
	end
end

-------------------
-- npc_on_get_all_from_corpse(npc,corpse)
-------------------
function npc_on_get_all_from_corpse(npc,corpse)
	--alun_utils.debug_write("npc_on_get_all_from_corpse")
	for i=1, #intercepts.npc_on_get_all_from_corpse do
		intercepts.npc_on_get_all_from_corpse[i](npc,corpse)
	end
end

-------------------
-- npc_on_fighting_actor(npc)
-------------------
function npc_on_fighting_actor(npc)
	for i=1, #intercepts.npc_on_fighting_actor do
		intercepts.npc_on_fighting_actor[i](npc)
	end
end

--------------------
-- npc_on_item_take_from_box(npc,box,item)
--------------------
function npc_on_item_take_from_box(npc,box_item)
	for i=1, #intercepts.npc_on_item_take_from_box do
		intercepts.npc_on_item_take_from_box[i](npc,box,item)
	end
end

-------------------
-- squad_on_update(squad)
-------------------
function squad_on_update(squad)
	for i=1, #intercepts.squad_on_update do
		intercepts.squad_on_update[i](squad)
	end
end

-------------------
-- squad_on_npc_creation(squad,npc,smart)
-------------------
function squad_on_npc_creation(squad,npc,smart)
	--alun_utils.debug_write(alun_utils.sr("squad_on_npc_creation squad=%s npc=%s smart=%s",squad and squad:name(),npc and npc:name(),smart and smart:name()))
	for i=1, #intercepts.squad_on_npc_creation do
		intercepts.squad_on_npc_creation[i](squad,npc,smart)
	end
end

-------------------
-- squad_on_npc_death(self,npc,killer)
-------------------
function squad_on_npc_death(squad,npc,killer)
	--alun_utils.debug_write("squad_on_npc_death")
	for i=1, #intercepts.squad_on_npc_death do
		intercepts.squad_on_npc_death[i](squad,npc,killer)
	end
end

-------------------
-- squad_on_unregister(self)
-------------------
function squad_on_unregister(squad)
	for i=1, #intercepts.squad_on_unregister do
		intercepts.squad_on_unregister[i](squad)
	end
end


-------------------
-- squad_can_switch_offline(self)
-------------------
function squad_can_switch_offline(squad,npc)
	for i=1, #intercepts.squad_can_switch_offline do
		if (intercepts.squad_can_switch_offline[i](squad) == false) then
			return false
		end
	end
end

-------------------
-- squad_assign_new_target(squad)
-------------------
function squad_assign_new_target(squad)
	local id
	for i=1, #intercepts.squad_assign_new_target do
		id = intercepts.squad_assign_new_target[i](squad)
		if (id) then
			break
		end
	end
	return id
end

-------------------
-- squad_can_help_actor(squad)
-------------------
function squad_can_help_actor(squad)
	local flag
	for i=1, #intercepts.squad_can_help_actor do
		flag = intercepts.squad_can_help_actor[i](squad)
		if (flag) then
			break
		end
	end
	return flag
end

-------------------
-- squad_on_add_npc(squad,npc,spawn_section,spawn_position,lv_id,gv_id)
-------------------
function squad_on_add_npc(squad,npc,spawn_section,spawn_position,lv_id,gv_id)
	for i=1, #intercepts.squad_on_add_npc do
		intercepts.squad_on_add_npc[i](squad,npc,spawn_section,spawn_position,lv_id,gv_id)
	end
end

-------------------
-- set_generic_scheme(npc, ini, stype)
-------------------
function set_generic_scheme(npc, ini, stype)
	--alun_utils.debug_write("set_generic_scheme start")
	for i=1, #intercepts.set_generic_scheme do
		intercepts.set_generic_scheme[i](npc, ini,stype)
	end
	--alun_utils.debug_write("set_generic_scheme end")
end

-------------------
-- scheme_reset(npc,scheme,section,st)
-------------------
function scheme_reset(npc,scheme,section,st)
	for i=1, #intercepts.scheme_reset do
		intercepts.scheme_reset[i](npc,scheme,section,st)
	end
end

-------------------
-- scheme_disable(npc,stype)
-------------------
function scheme_disable(npc,stype)
	for i=1, #intercepts.scheme_disable do
		intercepts.scheme_disable[i](npc,stype)
	end
end

-------------------
-- scheme_deactivate(npc,scheme,st)
-------------------
function scheme_deactivate(npc,scheme,st)
	for i=1, #intercepts.scheme_deactivate do
		intercepts.scheme_deactivate[i](npc,scheme,st)
	end
end

-------------------
-- monster_on_update(npc,st)
-------------------
function monster_on_update(npc,st)
	--alun_utils.debug_write("monster_on_update")
	for i=1, #intercepts.monster_on_update do
		intercepts.monster_on_update[i](npc,st)
	end
end

-------------------
-- monster_on_hit_callback(obj,amount,local_direction,who,bone_index)
-------------------
function monster_on_hit_callback(obj,amount,local_direction,who,bone_index)
	--alun_utils.debug_write("monster_on_hit_callback")
	for i=1, #intercepts.monster_on_hit_callback do
		intercepts.monster_on_hit_callback[i](obj,amount,local_direction,who,bone_index)
	end
end

-------------------
-- monster_on_death_callback(obj,who)
-------------------
function monster_on_death_callback(obj,who)
	--alun_utils.debug_write("monster_on_death_callback")
	for i=1, #intercepts.monster_on_death_callback do
		intercepts.monster_on_death_callback[i](obj,who)
	end
end

-------------------
-- monster_on_net_spawn(obj)
-------------------
function monster_on_net_spawn(obj)
	--alun_utils.debug_write("monster_on_net_spawn")
	for i=1, #intercepts.monster_on_net_spawn do
		intercepts.monster_on_net_spawn[i](obj)
	end
end

-------------------
-- monster_on_actor_use_callback(obj,who)
-------------------
function monster_on_actor_use_callback(obj,who)
	for i=1, #intercepts.monster_on_actor_use_callback do
		intercepts.monster_on_actor_use_callback[i](obj,who)
	end
end

------------------
-- main_menu_on_init()
------------------
function main_menu_on_init(menu)
	axr_main_options.main_menu_on_init(menu)
	
	if (closecaption and closecaption.main_menu_on_init) then
		closecaption.main_menu_on_init(menu)
	end
	for i=1, #intercepts.main_menu_on_init do
		intercepts.main_menu_on_init[i](menu)
	end
end

------------------
-- main_menu_on_quit()
------------------
function main_menu_on_quit(menu)
	if (closecaption and closecaption.main_menu_on_quit) then
		closecaption.main_menu_on_quit(menu)
	end
	for i=1, #intercepts.main_menu_on_quit do
		intercepts.main_menu_on_quit[i](menu)
	end
end

------------------
-- main_menu_on_keyboard(dik,keyboard_action,self)
------------------
function main_menu_on_keyboard(dik,keyboard_action,menu)
	for i=1, #intercepts.main_menu_on_keyboard do
		intercepts.main_menu_on_keyboard[i](dik,keyboard_action,menu)
	end
end

------------------
-- opt_menu_on_init()
------------------
function opt_menu_on_init(menu)
	axr_main_options.opt_menu_on_init(menu)

	for i=1, #intercepts.opt_menu_on_init do
		intercepts.opt_menu_on_init[i](menu)
	end
end

------------------
-- opt_menu_on_accept()
------------------
function opt_menu_on_accept(menu,optMgr,console)
	axr_main_options.opt_menu_on_accept(menu,optMgr,console)

	for i=1, #intercepts.opt_menu_on_accept do
		intercepts.opt_menu_on_accept[i](menu,optMgr,console)
	end
end

------------------
-- opt_menu_on_set_values()
------------------
function opt_menu_on_set_values(menu,optMgr)
	axr_main_options.opt_menu_on_set_values(menu,optMgr)

	for i=1, #intercepts.opt_menu_on_set_values do
		intercepts.opt_menu_on_set_values[i](menu,optMgr)
	end
end

------------------
-- physic_object_on_use_callback(obj,who)
------------------
function physic_object_on_use_callback(obj,who)
	for i=1, #intercepts.physic_object_on_use_callback do
		intercepts.physic_object_on_use_callback[i](obj,who)
	end
end

------------------
-- physic_object_on_hit_callback(obj, amount, local_direction, who, bone_index)
------------------
function physic_object_on_hit_callback(obj, amount, local_direction, who, bone_index)
	for i=1, #intercepts.physic_object_on_hit_callback do
		intercepts.physic_object_on_hit_callback[i](obj, amount, local_direction, who, bone_index)
	end
end

-------------------
-- on_save_game_load(fileName)		-- ui_load_dlg.script
-------------------
function on_save_game_load(fname)
	alun_utils.printf("collectgarbage before=%sKb",collectgarbage("count")*1024)
	collectgarbage("collect")
	alun_utils.printf("collectgarbage after=%sKb",collectgarbage("count")*1024)
end

--------------------
-- on_save_game_save(fileName)		-- ui_save_dlg.script
--------------------
function on_save_game_save(fname)
	last_save = fname
	
	-- force all queued actions to trigger
	event_queue(true)

	--alun_utils.printf("collectgarbage before=%sKb",collectgarbage("count")*1024)
	--collectgarbage("collect")
	--alun_utils.printf("collectgarbage after=%sKb",collectgarbage("count")*1024)
end

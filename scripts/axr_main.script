--[[
Copyright (C) 2012-2015 Alundaio
This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License

Callback and module manager for easy plug-in based script management
by Alundaio
--]]

-- axr_options.ini
config = alun_utils.cfg_file(alun_utils.fspath("$game_data$").."axr_options.ini")
-------------------------------------------------------------------------------------------------
REMOVE_ME_LC = nil 			-- Used by custom jump level command in xrs_debug_tools and faction select
------------------------------




--[[ 				REGISTER YOUR SCRIPT HERE
The list of scripts where on_game_start is called
--]]
local script_modules = { 	
	"modules", 
	"alife_storage_manager",
	"surge_manager",
	"psi_storm_manager",
	"phantom_manager", 
	"xrs_dyn_music", 
	"coc_treasure_manager", 
	"ui_mm_faction_select", 
	"axr_keybind",
	--"xrs_rnd_npc_loadout",
	--"axr_dynamic_spawn",
	"itms_manager",
	"xr_statistic",
	"m_mines",
	"axr_task_manager",
	"axr_companions",
	"xr_eat_medkit",
	"axr_trade_manager",
	"axr_task_manager"
}
	

-- Valid Callbacks (named intercepts to avoid namespace conflicts)
-- You must register a callback before or during on_game_load (ie. bind_actor net_spawn)
-- All unused callbacks will have their table deleted from intercepts (see on_game_load for implementation)
local intercepts = {
	-- _g.script

	-- ui_main_menu.script
	main_menu_on_keyboard		= {},
	main_menu_on_init			= {},
	main_menu_on_init_callbacks	= {},
	main_menu_on_quit			= {},

	-- ui_mm_opt_main.script 
	opt_menu_on_init			= {},
	opt_menu_on_accept			= {},
	opt_menu_on_set_values		= {},
	
	-- xr_motivator.script
	npc_on_use 					= {},
	npc_on_item_take 			= {},
	npc_on_item_drop 			= {},
	npc_on_net_spawn			= {},
	npc_on_net_destroy 			= {},
	npc_on_update				= {},
	npc_on_hit_callback			= {},
	npc_on_death_callback		= {},
	npc_add_precondition		= {},
	npc_on_item_take_from_box	= {},
	
	-- xr_combat_ignore.script
	npc_on_fighting_actor		= {},
	
	-- state_mgr_weapon.script
	npc_on_weapon_strapped		= {},
	npc_on_weapon_unstrapped	= {},
	npc_on_weapon_drop			= {},

	-- xr_hear.script
	npc_on_hear_callback		= {},

	-- se_stalker.script
	se_stalker_on_spawn			= {},

	-- se_actor.script
	se_actor_on_register		= {},
	se_actor_on_unregister		= {},
	se_actor_on_STATE_Write		= {},
	se_actor_on_STATE_Read		= {},

	-- xr_corpse_detection.script
	npc_on_get_all_from_corpse 	= {},

	-- sim_board.script
	squad_on_npc_creation		= {},
	
	-- sim_squad_scripted.script
	squad_assign_new_target		= {},
	squad_can_help_actor		= {},
	squad_on_npc_death			= {},
	squad_on_update				= {},
	squad_on_add_npc			= {},
	squad_can_switch_offline	= {},
	squad_on_unregister			= {},

	-- xr_logic.script
	on_pstor_save_all			= {},
	on_pstor_load_all			= {},

	-- bind_stalker.script
	on_key_press				= {},
	on_key_release				= {},
	actor_on_before_death		= {},
	on_game_load				= {},
	on_game_end					= {},
	actor_on_update				= {},
	--actor_on_weapon_no_ammo		= {},	-- TODO: Export from engine instead
	actor_on_weapon_zoom_in		= {},
	actor_on_weapon_zoom_out	= {},
	actor_on_item_take			= {},
	actor_on_item_take_from_box = {},
	actor_on_item_drop			= {},
	actor_on_item_use			= {},
	actor_on_trade				= {},
	actor_on_save				= {},
	actor_on_load				= {},
	actor_on_init				= {},
	actor_on_torch_enabled		= {},	-- TODO: Export from engine instead
	actor_on_torch_disabled		= {},	-- TODO: Export from engine instead
	actor_on_info_callback		= {},
	actor_on_hit_callback		= {},
	on_attach_vehicle			= {},
	on_detach_vehicle			= {},
	on_use_vehicle				= {},
	
	-- pda.script
	actor_on_leave_dialog		= {},

	-- bind_monster.script
	monster_on_update				= {},
	monster_on_hit_callback			= {},
	monster_on_net_spawn			= {},
	monster_on_death_callback		= {},
	monster_on_actor_use_callback   = {},

	-- bind_physic_object.script
	physic_object_on_hit_callback 	= {},
	physic_object_on_use_callback 	= {},

	-- axr_main (custom)
	on_level_changing				= {},
	
	-- Custom saving feature (uses marshal)
	save_state						= {},
	load_state						= {}
}

-----------------------------------------------------------
-- Global Callback Register
-- param 1 - name as type<string> (ie. intercepts[name])
-- param 2 - function to execute as type<function> or type<table>
-----------------------------------------------------------
function callback_set(name,func)
	if not (func) then
		return
	end
	if (intercepts[name]) then
		table.insert(intercepts[name],func)
	end
end

function callback_unset(name,func)
	if not (intercepts[name]) then
		return
	end

	local index
	for i=#intercepts[name],1,-1 do
		if (intercepts[name][i] == func) then
			index = i
			break
		end
	end

	if (index) then
		table.remove(intercepts[name],index)
	end
end

function make_callback(name,...)
	if not (intercepts[name]) then
		return 
	end
	for i=1, #intercepts[name] do
		if (intercepts[name][i]) then
			intercepts[name][i](...)
		end
	end
end

--------------------------------------------------------------------------------------------------------------------
-- Private functions
--------------------------------------------------------------------------------------------------------------------


function on_game_start()
	if (DEV_DEBUG) then 
		xrs_debug_tools.on_game_start()
	end
	for i=1,#script_modules do 
		if (_G[script_modules[i]]) then 
			if (_G[script_modules[i]].on_game_start) then
				_G[script_modules[i]].on_game_start()
			end
		else 
			printf("axr_main: Registered script module %s is absent",script_modules[i])
		end
	end
end


-------------------
-- on_game_load() ;Actor Net Spawn
-------------------
function on_game_load()
	math.randomseed(time_global())

	-- clean up intercepts table if callbacks are unused
	-- if needed this can be removed so that callbacks can be registered any time, not just before or during on_game_load
	--[[
	for k,v in pairs(intercepts) do
		if (#v == 0) then 
			intercepts[k] = nil
		end
	end
	--]]
end

-------------------
-- actor_on_update()
-------------------
actor_light = nil
function actor_on_update(se_actor,delta)
	local tg = time_global()
	
	-- evaluate event queue
	ProcessEventQueue()

	-- Check HudMsg
	if (ShowMessageTime) then
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("not_enough_money_mine")
		if custom_static ~= nil and tg > ShowMessageTime then
			hud:RemoveCustomStatic("not_enough_money_mine")
			ShowMessageTime = nil
		end
	end

	-- WISH GRANTER ZOMBIED-IMMORTALITY
	if (db.actor:has_info("actor_made_wish_immortal")) then 
		db.actor.health = 1
		db.actor.bleeding = 1
		db.actor.psy_health = 1
		db.actor.radiation = -1
	end
	
	local torch = db.actor:object("device_torch")
	if (torch and not actor_light and torch:torch_enabled()) then
		actor_light = true
		CreateScriptCallback("actor_on_torch_enabled")
	elseif (torch and not torch:torch_enabled()) then
		if (actor_light) then
			actor_light = false
			CreateScriptCallback("actor_on_torch_disabled")
		end
	end
end

-------------------
-- actor_on_weapon_no_ammo(wpn)
-------------------
function actor_on_weapon_no_ammo(binder,wpn)
	if not (intercepts.actor_on_weapon_no_ammo) then 
		return 
	end
	for i=1, #intercepts.actor_on_weapon_no_ammo do
		intercepts.actor_on_weapon_no_ammo[i](wpn)
	end
end

-------------------
-- actor_on_weapon_zoom_in(wpn)
-------------------
function actor_on_weapon_zoom_in(binder,obj,wpn)
	if not (intercepts.actor_on_weapon_zoom_in) then 
		return 
	end
	--printf("zoom in %s",wpn and wpn:name())
	for i=1, #intercepts.actor_on_weapon_zoom_in do
		intercepts.actor_on_weapon_zoom_in[i](wpn)
	end
end

-------------------
-- actor_on_weapon_zoom_out(wpn)
-------------------
function actor_on_weapon_zoom_out(binder,obj,wpn)
	if not (intercepts.actor_on_weapon_zoom_out) then 
		return 
	end
	--printf("zoom out %s",wpn and wpn:name())
	for i=1, #intercepts.actor_on_weapon_zoom_out do
		intercepts.actor_on_weapon_zoom_out[i](wpn)
	end
end

-------------------
-- actor_on_item_take(item)
-------------------
function actor_on_item_take(binder,item)
	if IsArtefact(item) then
		local anomal_zone = bind_anomaly_zone.parent_zones_by_artefact_id[item:id()]
		if anomal_zone ~= nil then
			anomal_zone:on_artefact_take(item)
		else
			bind_anomaly_zone.artefact_ways_by_id[item:id()] = nil
		end
		local artefact = item:get_artefact()
		artefact:FollowByPath("NULL",0,vector():set(500,500,500))
		xr_statistic.inc_founded_artefacts_counter(item:id())
	end
	treasure_manager.get_treasure_manager():on_item_take(item:id())
end

-------------------
-- actor_on_item_use(item)
-------------------
function actor_on_item_use(binder,item)
	local sec = item:section()
	if (sec == "drug_anabiotic") then 
		xr_effects.disable_ui_only(db.actor, nil)
		level.add_cam_effector("camera_effects\\surge_02.anm", 10, false, "bind_stalker.anabiotic_callback")
		level.add_pp_effector("surge_fade.ppe", 11, false)
		give_info("anabiotic_in_process")
		local con = get_console()
		_G.mus_vol = con:get_float("snd_volume_music")
		_G.amb_vol = con:get_float("snd_volume_eff")
		con:execute("snd_volume_music 0")
		con:execute("snd_volume_eff 0")
	elseif (atmosfear) and (sec == "drug_psy_blockade" or sec == "drug_radioprotector" or sec == "drug_antidot") then
		local boost_time = system_ini():r_float(sec,"boost_time")
		xr_logic.pstor_store(db.actor,sec.."_expiration",atmosfear.CTimeAddSec(game.get_game_time(),boost_time*level.get_time_factor()))
	end 
end

-------------------
-- actor_on_trade(item)
-------------------
function actor_on_trade(binder,item,sell_bye,money)
	if sell_bye == true then
		 game_stats.money_trade_update (money)
	else
		 game_stats.money_trade_update (-money)
	end
end

-------------------
-- actor_on_save(bind_stalker,packet)
-------------------
function actor_on_save(binder,packet)

	if (intercepts.on_level_changing) then
		local sim,gg = alife(),game_graph()
		local actor_gv = sim and gg:vertex(sim:actor().m_game_vertex_id)
		
		if (actor_gv and actor_gv:level_id() ~= sim:level_id()) then
			--printf("actor changing level")
			CreateScriptCallback("on_level_changing")
		end
	end
	
	if (REMOVE_ME_LC) then
		local sim = alife()
		local se_obj = sim:object(REMOVE_ME_LC)
		if (se_obj) then
			--printf("removing temp level_changer %s",se_obj:name())
			sim:release(se_obj,true)
		end
	end
	
	if (coc_treasure_manager) then
		coc_treasure_manager.save(packet)
	end
end

-------------------
-- actor_on_load(bind_stalker,packet)
-------------------
function actor_on_load(binder,packet)
	if (coc_treasure_manager) then
		coc_treasure_manager.load(packet)
	end
end

-------------------
-- squad_can_switch_offline(self)
-------------------
function squad_can_switch_offline(squad,npc)
	if (intercepts.squad_can_switch_offline) then 
		for i=1, #intercepts.squad_can_switch_offline do
			if (intercepts.squad_can_switch_offline[i](squad) == false) then
				return false
			end
		end
	end
end

-------------------
-- squad_assign_new_target(squad)
-------------------
function squad_assign_new_target(squad)
	if (intercepts.squad_assign_new_target) then
		local id
		for i=1, #intercepts.squad_assign_new_target do
			id = intercepts.squad_assign_new_target[i](squad)
			if (id) then
				break
			end
		end
		return id
	end
end

-------------------
-- squad_can_help_actor(squad)
-------------------
function squad_can_help_actor(squad)
	if (intercepts.squad_can_help_actor) then 
		local flag
		for i=1, #intercepts.squad_can_help_actor do
			flag = intercepts.squad_can_help_actor[i](squad)
			if (flag) then
				break
			end
		end
		return flag
	end
end

------------------
-- main_menu_on_init()
------------------
function main_menu_on_init(menu)
	math.randomseed(os.time())
	axr_main_options.main_menu_on_init(menu)
	-- THIS IS HERE BECAUSE ON_GAME_START is only triggered when alife simulator starts. We need this here to use icon editor
	if (DEV_DEBUG) then
		if (xrs_debug_tools) then xrs_debug_tools.on_game_start() end
	end 
	closecaption.main_menu_on_init(menu)
end

------------------
-- main_menu_on_quit()
------------------
function main_menu_on_quit(menu)
	closecaption.main_menu_on_quit(menu)
end

------------------
-- opt_menu_on_init()
------------------
function opt_menu_on_init(menu)
	axr_main_options.opt_menu_on_init(menu)
end

------------------
-- opt_menu_on_accept()
------------------
function opt_menu_on_accept(menu,optMgr,console)
	axr_main_options.opt_menu_on_accept(menu,optMgr,console)
end

------------------
-- opt_menu_on_set_values()
------------------
function opt_menu_on_set_values(menu,optMgr)
	axr_main_options.opt_menu_on_set_values(menu,optMgr)
end

-------------------
-- on_key_press
-------------------
function on_key_press(binder,key)
	make_callback("on_key_press",key)
end

-------------------
-- on_key_release
-------------------
function on_key_release(binder,key)
	make_callback("on_key_release",key)
end

-------------------
-- on_actor_before_death
-------------------
function actor_on_before_death(binder,whoID)
	--db.actor:set_health_ex(1)
	-- This is necessary to avoid engine crash when player dies with holder
	if (db.vehicle and db.actor.detach_vehicle) then 
		db.actor:detach_vehicle()
	end
	db.actor:kill(db.actor, true)
	make_callback("actor_on_before_death",whoID)
end

-----------------------
-- on_attach_vehicle
-----------------------
function on_attach_vehicle(binder,obj)
	db.vehicle = obj
	make_callback("on_attach_vehicle",obj)
end

-----------------------
-- on_detach_vehicle
-----------------------
function on_detach_vehicle(binder,obj)
	db.vehicle = nil
	make_callback("on_detach_vehicle",obj)
end

-----------------------
-- on_use_vehicle
-----------------------
function on_use_vehicle(binder,obj)
	make_callback("on_use_vehicle",obj)
end
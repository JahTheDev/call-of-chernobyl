--------------------------------
----- Written by Darryl123 -----
--------------------------------

-------------------------
----- Miscellaneous -----
-------------------------

-- Table of all items to consider as addons.
local addons_table = alun_utils.collect_sections(system_ini(), {"addons_table"})

-- Determines whether an addon is valid.
local function check_addon(addon, valid_addons)
	for k, v in pairs(valid_addons) do
		if (v == addon) then
			return true
		end
	end
	return false
end

-- Creates an item on the ground next to the actor.
local function create_item(section)
	return alife():create(section, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
end

-- Determines which weapon is to be modified.
function get_weapon()
	local weapon = db.actor:item_in_slot(db.actor:active_slot())
				or db.actor:item_in_slot(3)
				or db.actor:item_in_slot(2)
	return weapon
end

-- Initialises callbacks and other dependencies.
function on_game_start()
	get_console():execute("hud_fov 0.385")
	get_console():execute("snd_targets 1000")
	get_console():execute("snd_restart")
	RegisterScriptCallback("actor_on_item_use", on_item_use)
	RegisterScriptCallback("CUIActorMenu_OnItemFocusReceive",on_item_focus)
end

-- Transfers an item to the actor.
local function transfer_item(id)
	local item = level.object_by_id(id)
	if not (item) then 
		return false 
	end 
	db.actor:transfer_item(item, db.actor)
	return true
end


-------------------
----- Context -----
-------------------

-- Called when a context option is required.
function context_functor(weapon)
	-- Return if the weapon is invalid.
	if (not weapon) then
		return
	end
	
	-- Return if the weapon has no parent section.
	local parent_section = system_ini():r_string_ex(weapon:section(),"parent_section")
	if (not parent_section or weapon:section() == parent_section) then
		return
	end
	
	-- Return if the weapon is not in the actor's inventory.
	local weapon_object = alife():object(weapon:id())
	if (weapon_object == nil or weapon_object.parent_id ~= 0) then 
		return 
	end
	
	-- Return the context option to detach an addon.
	return game.translate_string("st_detach_scope")
end

-- Called when the context option is clicked.
function context_action_functor(weapon)
	detach_addon(weapon)
end

---------------------
----- Callbacks -----
---------------------

-- Called when the cursor focuses on an item.
function on_item_focus(item)
	-- No "scopes" section found for the weapon.
	if not (system_ini():line_exist(item:section(),"scopes")) then return end
	
	-- An addon has already been attached or none can be used.
	local parent_section = system_ini():r_string_ex(item:section(),"parent_section")
	if (not parent_section or item:section() ~= parent_section) then return end
	
	-- Highlight all addons this item can use.
	local scopes = alun_utils.parse_list(system_ini(), item:section(), "scopes")
	local inventory = ActorMenu.get_actor_menu()
	if not (scopes or (inventory and inventory:IsShown())) then return end
	for i=1,#scopes do 
		inventory:highlight_section_in_slot(scopes[i],EDDListType.iActorBag)
	end
end

-- Called when an item is used.
function on_item_use(item)
	-- Attachments
	if (addons_table[item:section()]) then
		attach_addon(item, get_weapon())
	end
	
	-- Multi-Tool (Compatibility)
	if (item:section() == "addons_box") then
		detach_addon(get_weapon())
	end
end

----------------------------
----- Addon Management -----
----------------------------

-- Attaches an addon to the weapon.
function attach_addon(item, weapon)
	-- Return if either parameter is invalid.
	if (not item or not weapon) then
		return
	end
	
	-- An addon has already been attached or none can be used.
	local parent_section = system_ini():r_string_ex(weapon:section(),"parent_section")
	if (not parent_section or weapon:section() ~= parent_section) then return end
	
	-- Modified weapon does not exist and as such can't be used.
	local child_section = (parent_section .. "_" .. item:section())
	if not (system_ini():section_exist(child_section)) then return end
	
	-- Determine whether the addon is valid for the weapon selected.
	local valid_addons = alun_utils.parse_list(system_ini(), weapon:section(), "scopes")
	if not (check_addon(item:section(), valid_addons)) then
		return
	end
	
	-- Create objects for the 'before' and 'after' attachment weapons.
	local old_weapon = alife():object(weapon:id())
	local new_weapon = alife():clone_weapon(old_weapon, child_section, old_weapon.position, old_weapon.m_level_vertex_id, old_weapon.m_game_vertex_id, old_weapon.parent_id, false)
	
	-- Release the addon and old unmodified weapon.
	local addon_object = alife():object(item:id())
	alife():release(addon_object, true)
	alife():release(old_weapon, true)
	
	-- Register the new modified weapon.
	alife():register(new_weapon)
end

-- Detaches an addon from the weapon.
function detach_addon(weapon)
	-- Return if the item is invalid.
	if (not weapon) then
		return
	end
	
	-- An addon has not been attached or none can be detached.
	local parent_section = system_ini():r_string_ex(weapon:section(),"parent_section")
	if (not parent_section or weapon:section() == parent_section) then return end
	
	-- Determine which addon is attached to the weapon.
	-- Create the item in the actor's inventory when found.
	for k, v in pairs(addons_table) do
		if (string.find(weapon:section(), k)) then
			give_object_to_actor(k)
			break
		end
	end
	
	-- Create objects for the 'before' and 'after' detachment weapons.
	local old_weapon = alife():object(weapon:id())
	local new_weapon = alife():clone_weapon(old_weapon, parent_section, old_weapon.position, old_weapon.m_level_vertex_id, old_weapon.m_game_vertex_id, old_weapon.parent_id, false)
	
	-- Release the old modified weapon.
	alife():release(old_weapon, true)
	
	-- Register the new unmodified weapon.
	alife():register(new_weapon)
end
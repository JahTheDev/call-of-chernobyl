---------------------------
-- task manager extender
-- by Alundaio

--actor_tagged_squad_by_id = {}
bounties_by_id = {}
-----------------------------------------------------------------------------
--								PRIVATE
-----------------------------------------------------------------------------

local function npc_on_death_callback(npc,who)
	local id = npc:id()
	
	for task_id,npc_id in pairs(bounties_by_id) do 
		if (npc_id == id) then 
			if (db.storage[id] and db.storage[id].tagged_by_actor == true) or (who and (who:id() == 0 or who:has_info("npcx_is_companion"))) then
				local tm = task_manager.get_task_manager()
				local task = tm.task_info[task_id]
				if (task and task.stage == 0) then 
					task.stage = 2
				end
			else 
				local tm = task_manager.get_task_manager()
				local task = tm.task_info[task_id]
				if (task and task.stage == 0) then 
					--task.stage = 3
					task.stage = 2 -- complete task anyway instead of failing
				end			
			end
			return
		end
	end 
end 

local function npc_on_hit_callback(npc,amount,local_direction,who,bone_index)
	local id = who and who:id()
	if not (id) then 
		return 
	end
	if (id == 0 or IsStalker(who) and who:has_info("npcx_is_companion")) then
		local npc_id = npc:id()
		if (db.storage[npc_id]) then 
			db.storage[npc_id].tagged_by_actor = true
		end
	end
end

--[[
local function squad_on_npc_death(squad,se_npc,killer)
	local npc_id = se_npc and se_npc.id
	local st = npc_id and db.storage[npc_id]
	if (st and st.tagged_by_actor) or (killer and (killer.id == 0 or alife():has_info(killer.id,"npcx_is_companion"))) then 
		actor_tagged_squad_by_id[squad.id] = true
	end
end
--]]

local skipped_tasks = {}
local function actor_on_leave_dialog()
	empty_table(skipped_tasks)
end 

local function save_state(m_data)
	m_data.bounties_by_id = bounties_by_id
end 

local function load_state(m_data)
	if (m_data.bounties_by_id) then 
		bounties_by_id = m_data.bounties_by_id
		m_data.bounties_by_id = nil
	end
end
-----------------------------------------------------------------------------
--								ON GAME START
-----------------------------------------------------------------------------
function on_game_start()
	RegisterScriptCallback("npc_on_death_callback",npc_on_death_callback)
	RegisterScriptCallback("npc_on_hit_callback",npc_on_hit_callback)
	--RegisterScriptCallback("monster_on_death_callback",npc_on_death_callback)
	RegisterScriptCallback("monster_on_hit_callback",npc_on_hit_callback)
	--RegisterScriptCallback("squad_on_npc_death",squad_on_npc_death)
	RegisterScriptCallback("actor_on_leave_dialog",actor_on_leave_dialog)
	RegisterScriptCallback("save_state",save_state)
	RegisterScriptCallback("load_state",load_state)
end

------------------------------------------------------------------------------
--								PUBLIC
------------------------------------------------------------------------------
-- automated ordered tasks
-- tasks must be named <section>_task_<number>
-- m_trader (ie. Sidorovich) use npc:name() instead
function get_first_available_task(npc,skip,is_sim)
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	
	local sec = is_sim and "simulation_task_" or npc:section() ~= "m_trader" and npc:section().."_task_" or npc:name().."_task_"
	local task_id = sec.."1"
	
	local count = 1
	while (task_manager.task_ini:section_exist(task_id)) do
		--printf("task_id=%s skipped=%s",task_id,skipped_tasks[task_id])
		if (skipped_tasks[task_id] ~= true and task_info[task_id] == nil and xr_conditions.has_completed_task_prerequisites(nil,nil,{task_id})) then
			if (skip) then 
				skipped_tasks[task_id] = true
				return
			else
				if (is_sim) then 
					local p = alun_utils.parse_list(task_manager.task_ini,task_id,"sim_communities",true)
					if (p[character_community(npc)] == true) then 
						return task_id
					end
				else 
					return task_id
				end
			end
		end
		count = count + 1
		task_id = sec..tostring(count)
	end
end

function get_first_finished_task(npc,is_sim)
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	
	local sec = is_sim and "simulation_task_" or npc:section() ~= "m_trader" and npc:section().."_task_" or npc:name().."_task_"
	local task_id = sec.."1"
	
	local count = 1
	while (task_manager.task_ini:section_exist(task_id)) do
	--	printf("get_first_finished_task task_id=%s",task_id)
		if (task_info[task_id] and task_info[task_id].stage ~= nil and task_info[task_id].stage == alun_utils.read_from_ini(task_manager.task_ini,task_id,"stage_complete","float")) then
			--printf("get_first_finished_task task_id=%s is_sim=%s is_giver=%s",task_id,is_sim,alun_utils.load_var(npc,task_id.."_is_giver"))
			if (is_sim) then 
				if (task_info[task_id].task_giver_id) then 
					if (npc:id() == task_info[task_id].task_giver_id) then 
						return task_id
					end 
					local se_obj = alife():object(npc:id())
					if (se_obj and se_obj.group_id ~= 65535 and se_obj.group_id == task_info[task_id].task_giver_id) then 
						return task_id
					end 				
				end
			else 
				return task_id
			end 
		end
		count = count + 1
		task_id = sec..tostring(count)
	end
end

function set_finished_task_complete(npc,is_sim)
	local task_id = get_first_finished_task(npc,is_sim)
	if not (task_id) then 
		return 
	end 

	task_manager.get_task_manager():set_task_completed(task_id)
end

function trigger_fetch_func(task_id)
	--printf("triiger_fetch_func %s",task_id)
	local fetch_func = xr_logic.parse_condlist(nil, "task_manager", "condlist", utils.cfg_get_string(task_manager.task_ini, task_id, "fetch_func", nil, false, "", ""))
	if (fetch_func) then 
		xr_logic.pick_section_from_condlist(db.actor,db.actor,fetch_func)
	end
end 

function get_random_available_task(npc,is_sim)
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	
	local sec = is_sim and "simulation_task_" or npc:section() ~= "m_trader" and npc:section().."_task_" or npc:name().."_task_"
	local task_id = sec.."1"
	
	local avail = {}
	local count = 1
	while (task_manager.task_ini:section_exist(task_id)) do
		if (task_info[task_id] == nil and xr_conditions.has_completed_task_prerequisites(nil,nil,{task_id})) then 
			table.insert(avail,task_id)
		end
		count = count + 1
		task_id = sec..tostring(count)
	end
	
	if (#avail > 0) then 
		return avail[math.random(#avail)]
	end
end

function get_task_job_description(task)
	return alun_utils.read_from_ini(task_manager.task_ini,task,"job_descr","string")
end 

function get_fetch_task_description(task)
	return alun_utils.read_from_ini(task_manager.task_ini,task,"fetch_descr","string")
end 

function get_task_complete_text(task)
	return alun_utils.read_from_ini(task_manager.task_ini,task,"task_complete_descr","string")
end

function is_task_on_complete_stage(task)
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	if not (task_info[task_id]) then 
		return false 
	end 
	return task_info[task_id].stage ~= nil and task_info[task_id].stage == alun_utils.read_from_ini(task_manager.task_ini,task,"stage_complete","number")
end

function npc_has_task_to_give(npc,is_sim)
	return get_first_available_task(npc,nil,is_sim) ~= nil
end

function npc_give_first_available_ordered_task(npc,is_sim)
	local new_task = get_first_available_task(npc,nil,is_sim)
	if not (new_task) then 
		return 
	end 
	local se_obj = npc and alife():object(npc:id())
	local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
	task_manager.get_task_manager():give_task(new_task,giver_id)
end

function clear_skipped_tasks()
	empty_table(skipped_tasks)
end

function is_task_giver_valid(task)
	local id = task.task_giver_id
	local se_obj = id and alife():object(id)
	if not (se_obj) then 
		--printf("is_task_giver_valid se_obj nil id=%s   %s",id,task.id)
		return false 
	end 
	
	if (se_obj:clsid() == clsid.online_offline_group_s or se_obj:clsid() == clsid.script_trader) then 
		return true 
	end
	
	if not (IsStalker(nil,se_obj:clsid()) and se_obj:alive()) then
		printf("is_task_giver_valid giver not alive %s",task.id)
		return false
	end

	return true
end
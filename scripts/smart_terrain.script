------------------------------
-- smart_terrain and gulag job system
--
-- Revamped by Alundaio
------------------------------

-- How many jobs are checked per update per npc, for a job
local STEP_SIZE 			= 5
local STEP_SIZE_OFFLINE 	= 1
local ALLOW_USE_MARSHAL 	= false

------------------------------------------
local level,alife,game_graph,math,pairs,tostring,tonumber = level,alife,game_graph,math,pairs,tostring,tonumber
------------------------------------------

local locations_ini	= ini_file("misc\\smart_terrain_masks.ltx")
nearest_to_actor_smart = {id = nil , dist = math.huge}

local function job_avail_to_npc(npc_info, job, smart)
	if (smart.dead_time[job.section]) then
		return false
	end

	local precond = gulag_general.get_job_precondition(job)
	if (precond) then
		return precond(npc_info.se_obj, smart, job, npc_info)
	end

	return true
end

local function arrived_to_smart(obj, smart)
	--alun_utils.debug_nearest(obj,"check arrived_to_smart %s",smart:name())

	if not (obj and smart) then 
		return false 
	end 
	
	local cls = obj and obj.clsid and obj:clsid()
	if not (cls) then 
		return false 
	end
	
	local gg = game_graph()
	local obj_gv, obj_pos = gg:vertex(obj.m_game_vertex_id), obj.position
	local smart_gv = gg:vertex(smart.m_game_vertex_id)
	
	if obj_gv:level_id() ~= smart_gv:level_id() then
		return false 
	end
	
	if (IsHelicopter(nil,cls)) then 
		return true 
	end 

	local squad = obj.group_id and SIMBOARD.squads[obj.group_id]
	
	local script_target = squad and squad:get_script_target() and alife():object(squad:get_script_target())
	--alun_utils.debug_nearest(obj,"squad=%s script_id=%s smart_id=%s",squad and squad:name(),script_target and script_target:name(),smart:name())
	if (squad) then
		if (squad.m_game_vertex_id == smart.m_game_vertex_id) then 
			return true 
		end 
		
		if (squad.current_action == 1 and squad.assigned_target_id == smart.id) then 
			return true 
		end
		
		if (is_squad_monster[squad.player_id] and squad:get_script_target() == nil) then 
			return squad.position:distance_to_sqr(smart.position) <= 625
		end

		return squad.always_arrived or squad.position:distance_to_sqr(smart.position) <= smart.arrive_dist^2
	end 

	return obj_pos:distance_to_sqr(smart.position) <= 900
end

----------------------------------------------------------------------------------------------------------------------
-- Êëàññ "se_smart_terrain". Îáåñïå÷èâàåò ïîääåðæêó smart terrain â ÎÔËÀÉÍÅ.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" (cse_alife_smart_zone)
function se_smart_terrain:__init(section) super(section)
	self.npc_by_job_section = {}
	self.dead_time = {}
	self.npc_info  = {}
	self.arriving_npc  = {}
	self.__campfire_check_time = game.get_game_time()
	
	if (USE_MARSHAL and ALLOW_USE_MARSHAL) then 
		RegisterScriptCallback("save_state",self.save_state,self)
	end
end
function se_smart_terrain:on_before_register()
	cse_alife_smart_zone.on_before_register(self)
	sim_board.get_sim_board():register_smart(self)
end

function se_smart_terrain:on_register()
	--alun_utils.debug_write(strformat("%s:ON_REGISTER start",self:name()))
	cse_alife_smart_zone.on_register(self)

	local sim = alife()
	local gg = game_graph()
	local actor_level = sim:level_name(gg:vertex(sim:actor().m_game_vertex_id):level_id())
	
	self.smart_level = alife():level_name(game_graph():vertex(self.m_game_vertex_id):level_id())
	self.is_on_actor_level = actor_level == self.smart_level

	-- Disable any smart terrain that is not on actor's level and not linked to actor's level through ai_tweaks\simulation_objects.ltx
	if not (self.is_on_actor_level) then
		if (DEACTIVATE_SIM_ON_NON_LINKED_LEVELS) then
			if not (string.find(simulation_objects.config:GetValue(actor_level,"target_maps",0,""),self.smart_level)) then
				SIMBOARD.smarts[self.id] = nil
				self.disabled = true
				--alun_utils.debug_write(strformat("%s:ON_REGISTER END (DISABLED)",self:name()))
				return
			end
		end
	end

	self.smart_alife_task = CALifeSmartTerrainTask(self.m_game_vertex_id, self.m_level_vertex_id)
	
	story_objects.check_spawn_ini_for_story_id(self)
	simulation_objects.get_sim_obj_registry():register(self)
	
	self.b_registred = true

	SIMBOARD:init_smart(self)
	
	self:load_jobs()

	if (self.need_init_npc) then
		self.need_init_npc = nil
		self:init_npc_after_load()
	end
	
	self:register_delayed_npc()

	self.check_time = time_global()
	--alun_utils.debug_write(strformat("%s:ON_REGISTER END",self:name()))
end

function se_smart_terrain:on_unregister()
	cse_alife_smart_zone.on_unregister(self)
	SIMBOARD:unregister_smart(self)
	unregister_story_object_by_id(self.id)
	simulation_objects.get_sim_obj_registry():unregister(self)
end

function se_smart_terrain:read_params()
	local ini = self:spawn_ini()

	if not ini:section_exist( "smart_terrain" ) then
		printf( "[smart_terrain %s] no configuration!", self:name() )
		self.disabled = true
		return
	end

	local filename = utils.cfg_get_string(ini, "smart_terrain", "cfg", 	self, false, "")
	if not (filename) then
		printf("no configuration file defined in spawn ini for %s",self:name())
		--filename = "scripts\\"..tostring(self.level_name).."\\smart\\"..self:name()..".ltx"
	end

	local fs = getFS()
	if filename then
		if fs:exist("$game_config$",filename) then
			ini = ini_file(filename)
		else
			printf("There is no configuration file [%s] in smart_terrain [%s]", filename, 	self:name())
		end
	end
	
	self.ini = ini

	self.sim_type		= utils.cfg_get_string(ini, "smart_terrain", "sim_type", 		self, false, "", "default")

	--if valid_territory[self.sim_type] == nil then
		--printf("Wrong sim_type value [%s] in smart [%s]", self.sim_type, self:name())
	--end

	self.squad_id		= utils.cfg_get_number(ini, "smart_terrain", "squad_id", 		self, false, 0)
	self.respawn_sector = utils.cfg_get_string(ini, "smart_terrain", "respawn_sector", 	self, false, "")
	self.respawn_radius  = utils.cfg_get_number(ini, "smart_terrain", "respawn_radius", 	self, false, 100)^2
	if self.respawn_sector ~= nil then
		if self.respawn_sector == "default" then
			self.respawn_sector = "all"
		end
		self.respawn_sector = xr_logic.parse_condlist(nil, "smart_terrain", "respawn_sector", self.respawn_sector)
	end

	self.forbidden_point	= utils.cfg_get_string(ini, "smart_terrain", "forbidden_point", self, false, "")

	self.def_restr		= utils.cfg_get_string(ini, "smart_terrain", "def_restr", 	self, false, "", nil)
	self.att_restr		= utils.cfg_get_string(ini, "smart_terrain", "att_restr", 	self, false, "", nil)
	self.safe_restr		= utils.cfg_get_string(ini, "smart_terrain", "safe_restr", 	self, false, "", nil)

	self.spawn_point	= utils.cfg_get_string(ini, "smart_terrain", "spawn_point", 	self, false, "")

	self.arrive_dist	= utils.cfg_get_number(ini, "smart_terrain", "arrive_dist", 	self, false, 50)

	local max_population = utils.cfg_get_string(ini, "smart_terrain", "max_population", self, false, "", 0)
	local parsed_condlist = xr_logic.parse_condlist(nil, "smart_terrain", "max_population", max_population)
	self.max_population = tonumber(xr_logic.pick_section_from_condlist(get_story_object("actor"), nil, parsed_condlist))

	self.death_idle_time = utils.cfg_get_number(ini, "smart_terrain", "death_idle_time", 	self, false, 600)

	if level.patrol_path_exists(self:name() .. "_traveller_actor") then
		--printf("Smart_terrain [%s] has no traveller_actor path!!!!!", self:name())
		self.traveler_actor_path = self:name() .. "_traveller_actor"
	end

	if level.patrol_path_exists(self:name() .. "_traveller_squad") then
		--printf("Smart_terrain [%s] has no traveller_squad path!!!!!", self:name())
		self.traveler_squad_path = self:name() .. "_traveller_squad"
	end

	if not locations_ini:section_exist(self:name()) then
		printf("! SMART_TERRAIN [%s] has no terrain_mask section in smart_terrain_masks.ltx!!!",self:name())
	end
	
	self.faction_controlled = utils.cfg_get_string(ini, "smart_terrain", "faction_controlled", self, false, "", nil)
	local spawn_num = self.faction_controlled and utils.cfg_get_string(ini, smart_terrain, "faction_respawn_num", 	self, false, "", "1")
	if (spawn_num) then 
		self.faction_respawn_num = xr_logic.parse_condlist(nil, smart_terrain, "faction_respawn_num", spawn_num)
	end
				
	self.respawn_only_smart = utils.cfg_get_bool(ini, "smart_terrain", "respawn_only_smart", self, false, false)
	self.respawn_idle = utils.cfg_get_number(ini, "smart_terrain", "respawn_idle", 	self, false, 3000)
	self.respawn_only_level = utils.cfg_get_bool(ini, "smart_terrain", "respawn_only_level", self, false, false)
	self.respawn_point = false
	
	local respawn_params = utils.cfg_get_string(ini, "smart_terrain", "respawn_params", 		self, false, "", nil)
	if not (respawn_params) then 
		return 
	end
	
	if not ini:section_exist(respawn_params) then
		printf("Wrong smart_terrain respawn_params section [%s](there is no section)", respawn_params)
		return
	end

	local n = ini:line_count(respawn_params)
	if n == 0 then
		printf("Wrong smart_terrain respawn_params section [%s](empty params)", respawn_params)
		return
	end

	self.respawn_params 	= {}
	self.already_spawned	= {}
	self.respawn_point		= true

	for j=0,n-1 do
		local result, prop_name, prop_condlist = ini:r_line(respawn_params,j,"","")
		if not ini:section_exist(prop_name) then
			printf("Wrong smatr_terrain respawn_params section [%s] prop [%s](there is no section)", respawn_params, prop_name)
		else
			local spawn_num = utils.cfg_get_string(ini, prop_name, "spawn_num", 	self, false, "", nil)
			if not (spawn_num) then 
				printf("Wrong smatr_terrain respawn_params section [%s] prop [%s] line [spawn_num](there is no line)", respawn_params, prop_name)
			else
				spawn_num = xr_logic.parse_condlist(nil, prop_name, "spawn_num", spawn_num)
				self.respawn_params[prop_name] 			= {}
				self.already_spawned[prop_name]			= {}
				self.respawn_params[prop_name].num		= spawn_num
				self.already_spawned[prop_name].num	= 0
				
				local spawn_squads = utils.cfg_get_string(ini, prop_name, "spawn_squads", 	self, false, "", nil)
				local spawn_helicopter = utils.cfg_get_string(ini, prop_name, "spawn_helicopter", 	self, false, "", nil)
				if (spawn_helicopter) then 
					spawn_helicopter = utils.parse_names(spawn_helicopter)
					self.respawn_params[prop_name].helicopter = spawn_helicopter
				elseif (spawn_squads) then
					spawn_squads = utils.parse_names(spawn_squads)
					self.respawn_params[prop_name].squads = spawn_squads
				else
					printf("Wrong smatr_terrain respawn_params section [%s] prop [%s] line [spawn_squads](there is no line)", respawn_params, prop_name)
					return
				end
			end
		end
	end
	
	if (self.faction_controlled) then 
		local p = alun_utils.str_explode(self.faction_controlled,",")
		if (p) then
			local squads_by_faction = {
				["stalker"] = "stalker_sim_squad_novice, stalker_sim_squad_advanced, stalker_sim_squad_veteran",
				["bandit"] = "bandit_sim_squad_novice, bandit_sim_squad_advanced, bandit_sim_squad_veteran",
				["ecolog"] = "ecolog_sim_squad_novice, ecolog_sim_squad_advanced, ecolog_sim_squad_veteran",
				["army"] = "army_sim_squad_novice, army_sim_squad_advanced, army_sim_squad_veteran",
				["csky"] = "csky_sim_squad_novice, csky_sim_squad_advanced, csky_sim_squad_veteran",
				["killer"] = "merc_sim_squad_novice, merc_sim_squad_advanced, merc_sim_squad_veteran",
				["monolith"] = "monolith_sim_squad_novice, monolith_sim_squad_advanced, monolith_sim_squad_veteran",
				["dolg"] = "duty_sim_squad_novice, duty_sim_squad_advanced, duty_sim_squad_veteran",
				["freedom"] = "freedom_sim_squad_novice, freedom_sim_squad_advanced, freedom_sim_squad_veteran"
			}
			
			for i,faction in pairs(p) do
				local prop_name = "faction_controlled_"..faction
				if (squads_by_faction[prop_name]) then
					self.respawn_params[prop_name] = {}
					self.already_spawned[prop_name]	= {}
					self.respawn_params[prop_name].num = self.faction_respawn_num
					self.already_spawned[prop_name].num	= 0
					local spawn_squads = utils.parse_names(squads_by_faction[faction])
					self.respawn_params[prop_name].squads = spawn_squads
					self.respawn_params[prop_name].faction = faction
				end
			end
		end	
	end
end

function se_smart_terrain:fill_npc_info(obj)
	--alun_utils.debug_write(strformat("%s:fill_npc_info %s",self:name(),obj and obj:name()))
	local cls = obj.clsid and obj:clsid()
	if not (cls) then 
		return printf("fill_npc_info invalid clsid for %s",obj and obj:name())
	end
	
	local stype = IsStalker(nil,cls) and 0 or IsMonster(nil,cls) and 1 or IsHelicopter(nil,cls) and 3 or nil
	if not (stype) then 
		return printf("fill_npc_info invalid stype for %s [clsid=%s]",obj and obj:name(),cls)
	end 
	
	local npc_info 			= {}
	npc_info.se_obj			= obj
	npc_info.need_job		= "nil"
	npc_info.job			= nil
	npc_info.begin_job		= false
	npc_info.stype 			= stype
	return npc_info
end

function se_smart_terrain:register_delayed_npc()
	if (self.npc_to_register) then
		for k,v in pairs(self.npc_to_register) do
			--alun_utils.debug_write(strformat("%s:register_delayed_npc %s",self:name(),v and v:name()))
			self:register_npc(v)
		end
		self.npc_to_register = nil
	end
end

function se_smart_terrain:register_npc(obj)
	--alun_utils.debug_write(strformat("%s:register_npc %s",self:name(),obj and obj:name()))
	-- ensure registration is clean
	if (self.arriving_npc[obj.id] or self.npc_info[obj.id]) then
		--self.arriving_npc[obj.id] = nil
		--self:clear_job(obj.id,true)
		return
	end
	
	local cls = obj.clsid and obj:clsid()
	if not (cls) then 
		return printf("register_npc no clsid! %s",obj and obj:name())
	end 
	
	-- dynamic companions cannot register
	if (IsStalker(nil,cls) and alife():has_info(obj.id,"npcx_is_companion")) then 
		return 
	end 
	
	--smart not yet registered
	if not (self.b_registred) then
		if not (self.npc_to_register) then
			self.npc_to_register = {}
		end
		self.npc_to_register[obj.id] = obj
		--table.insert(self.npc_to_register, obj)
		return
	end
	
	if (IsMonster(nil,cls)) then
		obj:smart_terrain_task_activate()
	end

	obj.m_smart_terrain_id = self.id

	if (arrived_to_smart(obj, self)) then
		self.npc_info[obj.id] = self:fill_npc_info(obj)
		self.dead_time = empty_table(self.dead_time)
		self:select_npc_job(self.npc_info[obj.id])
		
		local comm = IsStalker(nil,obj:clsid()) and obj:community()
		if (comm ~= "zombied" and self:only_faction_on_jobs(comm)) then 
			self.faction = comm
		end
	else
		self.arriving_npc[obj.id]  = obj
	end
end

function se_smart_terrain:only_faction_on_jobs(faction)
	for id,npc_info in pairs(self.npc_info) do
		se_obj = npc_info.se_obj
		local comm = se_obj and IsStalker(nil,se_obj:clsid()) and se_obj:community()
		if (comm and comm ~= zombied and comm ~= faction) then
			return false
		end 
	end
	return true
end 

function se_smart_terrain:unregister_npc(obj)
	--alun_utils.debug_write(strformat("%s:unregister_npc %s",self:name(),obj and obj:name()))
	
	self.arriving_npc[obj.id] = nil
	
	if (obj.clear_smart_terrain) then
		obj:clear_smart_terrain()
	end
	
	self:clear_job(obj.id,true)
	
	local st = db.storage[obj.id]
	if (st and st.object) then
		local cls = obj.clsid and obj:clsid()
		
		if not (cls) then 
			return 
		end
		
		local stype = IsStalker(nil,cls) and 0 or IsMonster(nil,cls) and 1 or IsHelicopter(nil,cls) and 3 or nil
		if not (stype) then 
			return 
		end
		
		xr_logic.initialize_obj(st.object, st, false, db.actor, stype)
	end

	--printf("self.npc_info[obj.id] = nil !!! obj.id=%s  [%s]", obj.id,obj:name())
end

function se_smart_terrain:clear_dead(obj)
	--alun_utils.debug_write(strformat("%s:clear_dead %s",self:name(),obj and obj:name()))
	
	self.arriving_npc[obj.id] = nil
	
	if (obj.clear_smart_terrain) then
		obj:clear_smart_terrain()
	end
	
	self:clear_job(obj.id,true)

	--printf("clear_dead():self.npc_info[obj.id] = nil !!! obj.id=%s  [%s]", obj.id,obj:name())
end

function se_smart_terrain:task(obj)
	--alun_utils.debug_write(strformat("%s:task %s",self:name(),obj and obj:name()))
	if (self.disabled) then
		return self.smart_alife_task
	end

	if self.arriving_npc[obj.id] ~= nil then
		return self.smart_alife_task
	end

	return self.npc_info[obj.id] and self.npc_info[obj.id].job and self.npc_info[obj.id].job.alife_task or self.smart_alife_task
end

local function validate_patrol_path(path_name,gg)
	local p = patrol(path_name)
	local ret = true
	if (p) then 
		local cnt = p:count()
		for i=0,cnt-1 do
			if not (gg:valid_vertex_id(p:game_vertex_id(i))) then 
				printf("validate_patrol_path WARNING: %s: invalid game_vertex_id for point %s",path_name,i)
				ret = false
			end
		end
	end
	return ret
end 

function se_smart_terrain:load_jobs()
	if (self.disabled) then
		return
	end
	
	--alun_utils.debug_write(strformat("%s:load_jobs %s  Before",self:name(),obj and obj:name()))

	-- load job data from dynamic ltx from gulag_general.script
	gulag_general.load_job(self)
	if not (self.ltx) then 
		printf("CRITICAL ERROR: %s does not have a dynamic ltx!",self:name())
		return
	end
	--alun_utils.debug_write(strformat("%s:load_jobs %s  After",self:name(),obj and obj:name()))
	
	-- Setup Alife Tasks for smart's gulag jobs
	local job,active_section,section,ltx, path_field, path_name, smartcover, smartcover_name, prefix_name, job_type
	local gg, CALifeSmartTerrainTask,level = game_graph(),CALifeSmartTerrainTask,level
	
	local table_of_jobs = {self.stalker_jobs,self.monster_jobs,self.heli_jobs}
	local tbl
	for n=1,#table_of_jobs do
		tbl = table_of_jobs[n]
		if (tbl and #tbl > 0) then
			for i=1,#tbl do
				job = tbl[i]

				section = job.section
				ltx = job.ltx or self.ltx
				if not (ltx:line_exist(section,"active")) then
					printf("gulag: ltx=%s  no 'active' in section %s", self.ltx_name, section)
				else
					active_section = ltx:r_string(section, "active")

					job_type = gulag_general.get_job_type(job)
					job.alife_task = self.smart_alife_task
					
					if (job_type == "path_job" or job_type == "heli_path_job") then
						path_field = "nil"
						
						path_field = 	(ltx:line_exist(active_section,"path_walk") and "path_walk" 
										or ltx:line_exist(active_section,"path_main") and "path_main" 
										or ltx:line_exist(active_section,"path_home") and "path_home" 
										or ltx:line_exist(active_section,"center_point") and "center_point" 
										or ltx:line_exist(active_section,"path_move") and "path_move" 
										or "nil")

						if (path_field == "nil") then
							printf("smart_terrain.load_jobs(): Cannot find path_field in section %s. ini_path=%s",active_section,job.ini_path)
						else
							prefix_name = gulag_general.get_job_prefix_name(job)
							if (prefix_name) then 
								path_name = (prefix_name == "nil" and "" or prefix_name) .. ltx:r_string(active_section, path_field)
							else 
								path_name = self:name() .. "_" .. ltx:r_string(active_section, path_field)
							end 

							if (path_field == "center_point") then
								if level.patrol_path_exists(path_name.."_task") then
									path_name = path_name.."_task"
								end
							end
							
							if (level.patrol_path_exists(path_name)) then
								if not (job_type == "heli_path_job") then
									if (validate_patrol_path(path_name,gg)) then
										job.alife_task = CALifeSmartTerrainTask(path_name)
									end
								end
							else
								printf("%s:load_jobs() There is no such patrol path %s",self:name(),path_name)
							end
						end
					elseif (job_type == "smartcover_job") then
						smartcover_name = ltx:r_string(active_section, "cover_name")
						smartcover = se_smart_cover.registered_smartcovers[smartcover_name]

						if not (smartcover) then
							printf("There is an exclusive job with wrong smatrcover name [%s]  smartterrain [%s]", tostring(smartcover_name), self:name())
						else 
							job.alife_task = CALifeSmartTerrainTask(smartcover.m_game_vertex_id, smartcover.m_level_vertex_id)
						end
					end

					if (job.alife_task) then -- if a single job is failed, ignore and fill rest of job table
						job.game_vertex_id = job.alife_task:game_vertex_id()
						job.level_id	= gg:vertex(job.game_vertex_id):level_id()
						job.position = job.alife_task:position()
					end
				end
			end
		end
	end
end

function se_smart_terrain:clear_job(id,rem)
	--alun_utils.debug_write(strformat("%s:clear_job %s",self:name(),id))
	if (self.npc_info[id]) then 
		if (self.npc_info[id].job) then 
			self.npc_by_job_section[self.npc_info[id].job.section] = nil
		end
		if (rem) then
			self.npc_info[id] = nil
		end
	end
end 

function se_smart_terrain:update_jobs()
	if (self.disabled) then
		return
	end
	
	-- Fill NPC Job Info and Give them a job
	for id,se_obj in pairs(self.arriving_npc) do 
		if (se_obj) then 
			if (arrived_to_smart(se_obj,self)) then 
				self.npc_info[id] = self:fill_npc_info(se_obj)
				self.arriving_npc[id] = nil
			end 
		elseif (se_obj == false) then
			local sobj = alife():object(id)
			if (sobj) then 
				self.arriving_npc[id] = sobj
			else 
				self.arriving_npc[id] = nil
			end
		end
	end 	

	local gg = game_graph()
	self.level_id = self.level_id or gg:vertex(self.m_game_vertex_id):level_id()
	
	local se_obj
	-- Update Jobs for existing NPCs
	for id,npc_info in pairs(self.npc_info) do
		se_obj = npc_info.se_obj
		if (se_obj) then
			if (self.level_id == gg:vertex(se_obj.m_game_vertex_id):level_id()) then
				self:select_npc_job(npc_info)
			else 
				self.arriving_npc[id] = se_obj
				self:clear_job(id,true)
			end
		else
			self:clear_job(id,true)
		end
	end
end

function se_smart_terrain:select_npc_job(npc_info,now,surge_started)
	if (self.disabled) then
		return
	end

	--alun_utils.debug_write(strformat("%s:select_npc_job %s",self:name()))
	
	if not (npc_info and npc_info.se_obj and npc_info.stype) then 
		return printf("%s no npc_info!",self:name())
	end
	
	-- reference job table according to race
	local jobs = npc_info.stype == 0 and self.stalker_jobs or npc_info.stype == 1 and self.monster_jobs or npc_info.stype == 3 and self.heli_jobs
	if not (jobs) then 
		return printf("%s no job table for %s [stype = %s]",self:name(),npc_info.se_obj:name(),npc_info.stype)
	end
	
	local new_job
	
	-- If the NPC has an existing job link, validate it and iterate job table
	-- for a higher priority job according to defined STEP_SIZE
	if (npc_info.job) then

		-- Make sure current job is still available
		if (self.npc_by_job_section[npc_info.job.section] == npc_info.se_obj.id) then

			-- Make sure current job is still available
			if (job_avail_to_npc(npc_info,npc_info.job,self)) then

				if not (npc_info.current_index) then
					npc_info.current_index = 1
				end

				local itr_job
				local npc_id
				local step = 1
				while (new_job == nil and step <= (now and #jobs or st and STEP_SIZE or STEP_SIZE_OFFLINE)) do
					step = step + 1

					if (npc_info.current_index > #jobs) then
						npc_info.current_index = 1
					end

					-- Step through job table one step at a time looking for a higher prior job
					itr_job = jobs[npc_info.current_index]
					npc_info.current_index = npc_info.current_index + 1

					npc_id = self.npc_by_job_section[itr_job.section]
					
					-- Check empty job
					if (npc_id == nil or npc_id == npc_info.se_obj.id) then
						-- Find only higher priority jobs if already linked to a job
						if (gulag_general.get_job_prior(itr_job) > gulag_general.get_job_prior(npc_info.job)) then
							if (job_avail_to_npc(npc_info, itr_job, self)) then
								-- Only take this higher priority job if when there is either no surge or if job is not in surge cover during surge; takes exclusive no matter what
								if (itr_job.exclusive or not xr_conditions.surge_started() or not surge_manager.job_in_surge_cover(npc_info.se_obj,npc_info.job)) then 
									new_job = itr_job
									npc_info.current_index = 1
								end
							end
						else
							-- Found a job with npc_id but npc isn't on the job, remove it
							if (npc_id == npc_info.se_obj.id and npc_info.job ~= itr_job) then
								self.npc_by_job_section[itr_job.section] = nil
							end
							-- Rest of jobs in table will be lower priority, so reset index
							npc_info.current_index = 1
						end
					end
				end
			else
				-- Job is no longer available, unlink job info
				self.npc_by_job_section[npc_info.job.section] = nil
				npc_info.job = nil
				npc_info.current_index = 1
			end
		else
			-- Job is not linked properly, npc_id doesn't match owner se_obj
			self.npc_by_job_section[npc_info.job.section] = nil
			npc_info.job = nil
			npc_info.current_index = 1
		end
	end

	if not (npc_info.job) then
		if not (npc_info.current_index) then
			npc_info.current_index = 1
		end

		local itr_job,npc_id
		local step = 1
		local st = db.storage[npc_info.se_obj.id]
		local STEP_SIZE_NO_JOB = #jobs
		while (new_job == nil and step <= (st and STEP_SIZE_NO_JOB or STEP_SIZE_OFFLINE)) do
			step = step + 1

			if (npc_info.current_index > STEP_SIZE_NO_JOB) then
				npc_info.current_index = 1
			end

			-- Step through job table one step at a time looking for a high prior job
			itr_job = jobs[npc_info.current_index]
			npc_info.current_index = npc_info.current_index + 1

			npc_id = self.npc_by_job_section[itr_job.section]
			
			-- validate existing job link 
			if (npc_id and not self.npc_info[npc_id]) then 
				self.npc_by_job_section[itr_job.section] = nil
			end
			
			-- Check empty job
			if (npc_id == nil and job_avail_to_npc(npc_info, itr_job, self)) then
				new_job = itr_job
				npc_info.current_index = 1
			end
		end

		if not (new_job) then
			return
		end
	end

	-- newly selected job
	if (new_job and new_job ~= npc_info.job) then

		-- Unassign npc_id from old job and unreference job section
		if (npc_info.job) then
			self.npc_by_job_section[npc_info.job.section] = nil
		end

		-- setup table that references NPCs by their job section
		self.npc_by_job_section[new_job.section] = npc_info.se_obj.id

		-- link up NPC info and references
		npc_info.job = new_job
		npc_info.begin_job = false

		-- grab storage and ensure object is online.
		local st = self.is_on_actor_level and db.storage[npc_info.se_obj.id]
		
		-- If NPC has storage, it is online, so switch logic
		if (st and st.object) then
			--xr_logic.switch_to_section(st.object, self.ltx, "nil")
			npc_info.begin_job = true
			empty_table(db.offline_objects[npc_info.se_obj.id])
			self:setup_logic(st.object)
			return
		end
	end

	if (npc_info.begin_job ~= true and npc_info.job) then
		-- grab storage and ensure object is online.
		local st = self.is_on_actor_level and db.storage[npc_info.se_obj.id]
		-- If NPC has storage it is online, so switch logic
		if (st and st.object) then
			npc_info.begin_job = true
			empty_table(db.offline_objects[npc_info.se_obj.id])
			self:setup_logic(st.object)
		end
	end
end

function se_smart_terrain:setup_logic(npc)
	--alun_utils.debug_write(self:name().." setup_logic "..tostring(npc and npc:name()))
	if not (npc) then
		printf("%s.setup_logic: NPC is nil",self:name())
		return
	end

	local npc_info = self.npc_info[npc:id()]
	if not (npc_info) then
		printf("%s.setup_logic: npc_info is nil! for id=%s",self:name(),npc:id())
		return
	end
	
	if not (npc_info.se_obj) then
		printf("%s.setup_logic: npc_info.se_obj is nil! for id=%s",self:name(),npc:id())
		return 
	end

	local job = npc_info.job
	if not (job) then
		printf("%s.setup_logic: npc_info has no job! for id=%s",self:name(),npc:id())
		self:unregister_npc(npc_info.se_obj)
		self:register_npc(npc_info.se_obj)
		return
	end

	--[[ fixed elsewhere now
	-- sanity; Not sure why this happens. It happens in all 3 Stalker games, NPCs try to switch logic for a job on another level, causes waypoint/path crashes. Re-register NPC
	if not (self.is_on_actor_level) then
		printf("%s.setup_logic: npc is trying to setup logic for a job on another level! npc=%s job=%s",self:name(),npc:name(),job.section)
		self:unregister_npc(npc_info.se_obj)
		--self:register_npc(npc_info.se_obj)
		return
	end

	-- sanity; Not sure why this happens. It happens in all 3 Stalker games, NPCs try to switch logic for a job on another level, causes waypoint/path crashes. Re-register NPC
	local gg = game_graph()
	local level = gg:vertex(npc:game_vertex_id()):level_id()
	if (level ~= gg:vertex(self.m_game_vertex_id):level_id() or level ~= gg:vertex(alife():actor().m_game_vertex_id):level_id()) then
		printf("%s.setup_logic: npc is trying to setup logic for a job on another level! npc=%s job=%s npc_level_id=%s",self:name(),npc:name(),job.section,level)
		self:unregister_npc(npc_info.se_obj)
		--self:register_npc(npc_info.se_obj)
		return
	end
	--]]

	local ltx = job.ltx or self.ltx
	local ltx_name = job.ini_path or self.ltx_name

	xr_logic.configure_schemes(npc, ltx, ltx_name, npc_info.stype, job.section, job.prefix_name or self:name())

	local sect = xr_logic.determine_section_to_activate(npc, ltx, job.section, db.actor)
	if utils.get_scheme_by_section(job.section) == "nil" then
		printf("[smart_terrain %s] section=%s, don't use section 'nil'!", self:name(), sect)
	end

	--printf("npc=%s ltx=%s sect=%s prefix=%s",npc:name(),ltx_name,sect,job.prefix_name or self:name())
	xr_logic.activate_by_section(npc, ltx, sect, job.prefix_name or self:name(), false)
end

function se_smart_terrain:getJob(obj_id)
	return self.npc_info[obj_id] and self.npc_info[obj_id].job or nil
end

function se_smart_terrain:idNPCOnJob(job_name)
	return self.npc_by_job_section[job_name]
end
function se_smart_terrain:switch_to_desired_job(npc)
	if (self.disabled) then
		return
	end

	local npc_id = npc:id()
	local npc_info = self.npc_info[npc_id]
	local changing_npc_id = self.npc_by_job_section[npc_info.need_job]

	-- unlink old job
	self:clear_job(npc_id)

	-- No changing npc, find new job
	if changing_npc_id == nil then
		self.npc_info[npc_id].job = nil
		self:select_npc_job(self.npc_info[npc_id])
		return
	end
	
	-- No changing npc, find new job
	if self.npc_info[changing_npc_id] == nil then
		self.npc_info[npc_id].job = nil
		self:select_npc_job(self.npc_info[npc_id])
		return
	end

	-- Changing NPC doesn't have a linked job, find us both jobs
	if not (self.npc_info[changing_npc_id].job) then
		self.npc_info[npc_id].job = nil
		self:select_npc_job(self.npc_info[npc_id])
		self:select_npc_job(self.npc_info[changing_npc_id])
		return
	end

	-- take job from changing_npc_id
	npc_info.job = self.npc_info[changing_npc_id].job
	self.npc_by_job_section[npc_info.job.section] = npc_id
	npc_info.begin_job = true
	npc_info.need_job = "nil"

	-- setup logic
	local st = db.storage[npc_id]
	if (st and st.object) then
		self:setup_logic(st.object)
	end

	-- tell changing_npc_id to GTFO and get a job
	self.npc_info[changing_npc_id].job = nil
	self:select_npc_job(self.npc_info[changing_npc_id])
end


function se_smart_terrain:save_state(m_data)
	if not (m_data.smart_terrains) then 
		m_data.smart_terrains = {}
	end
	
	if not (m_data.smart_terrains[self.id]) then 
		m_data.smart_terrains[self.id] = {}
	end
	
	m_data.smart_terrains[self.id].arriving_npc = {}
	for id,v in pairs(self.arriving_npc) do 
		table.insert(m_data.smart_terrains[self.id].arriving_npc,id)
	end
	
	m_data.smart_terrains[self.id].npc_info = {}
	for id,info in pairs(self.npc_info) do 
		if not (m_data.smart_terrains[self.id].npc_info[id]) then 
			m_data.smart_terrains[self.id].npc_info[id] = {}
		end 
		m_data.smart_terrains[self.id].npc_info[id].job_section = info.job and info.job.section
		m_data.smart_terrains[self.id].npc_info[id].begin_job = info.begin_job
		m_data.smart_terrains[self.id].npc_info[id].need_job = info.need_job
	end
	
	m_data.smart_terrains[self.id].dead_time = self.dead_time
	m_data.smart_terrains[self.id].already_spawned = self.already_spawned
	m_data.smart_terrains[self.id].last_respawn_update = self.last_respawn_update
end
--*******************************************************
-- ÑÅÉÂ/ËÎÀÄ
--*******************************************************
function se_smart_terrain:STATE_Write(packet)
	cse_alife_smart_zone.STATE_Write(self, packet)
	if (USE_MARSHAL and ALLOW_USE_MARSHAL) then 
		return 
	end
	--set_save_marker(packet, "save", false, "se_smart_terrain")

	-- Èíôîðìàöèþ î ÍÏÑ, èäóùèõ â ñìàðò
	local n = 0
	for k,v in pairs(self.arriving_npc) do
		n = n + 1
	end

	alun_utils.w_stpk(packet,"u8",n,"arriving_npc count")
	for k,v in pairs(self.arriving_npc) do
		alun_utils.w_stpk(packet,"u16",k,"arriving_npc id")
	end


	-- Èíôîðìàöèþ î ÍÏÑ â ñìàðòå
	n = 0
	for k,v in pairs(self.npc_info) do
		n = n + 1
	end

	--printf("%s:STATE_Write   JobCount=%s",self:name(),n)
	alun_utils.w_stpk(packet,"u8",n,"npc_info count")
	for id,info in pairs(self.npc_info) do
		alun_utils.w_stpk(packet,"u16",id,"npc_info id")
		alun_utils.w_stpk(packet,"stringZ",info.job and info.job.section or "nil","npc_info.job_section")
		alun_utils.w_stpk(packet,"bool",info.begin_job,"npc_info.begin_job")
		alun_utils.w_stpk(packet,"stringZ",tostring(info.need_job),"npc_info.need_job")
	end

	n = 0
	for k,v in pairs(self.dead_time) do
		n = n + 1
	end

	alun_utils.w_stpk(packet,"u8",n,"dead_time count")
	for k,v in pairs(self.dead_time) do
		alun_utils.w_stpk(packet,"stringZ",k,"dead_time job_section")
		alun_utils.w_stpk(packet,"CTime",v,"dead_time CTime")
	end

	if self.respawn_point then
		alun_utils.w_stpk(packet,"bool",true,"respawn_point")
		local n = 0
		for k,v in pairs(self.already_spawned) do
			n = n + 1
		end

		alun_utils.w_stpk(packet,"u8",n,"already_spawned count")
		for k,v in pairs(self.already_spawned) do
			alun_utils.w_stpk(packet,"stringZ",k,"already_spawned section")
			alun_utils.w_stpk(packet,"u8",v.num,"already_spawned count")
		end
		alun_utils.w_stpk(packet,"CTime",self.last_respawn_update,"last_respawn_update CTime")
	else
		alun_utils.w_stpk(packet,"bool",false,"respawn_point")
	end

	--set_save_marker(packet, "save", true, "se_smart_terrain")
end

function se_smart_terrain:STATE_Read(packet, size)
	--alun_utils.debug_write(strformat("%s:STATE_READ start",self:name()))
	cse_alife_smart_zone.STATE_Read(self, packet, size)
	
	self:read_params()
	self.need_init_npc = true
	
	if (USE_MARSHAL and ALLOW_USE_MARSHAL) then
		if (m_data.smart_terrains and m_data.smart_terrains[self.id]) then
			empty_table(self.arriving_npc)
			for i,id in pairs(m_data.smart_terrains[self.id].arriving_npc) do 
				self.arriving_npc[id] = false
			end 
			
			empty_table(self.npc_info)
			for id,v in pairs(m_data.smart_terrains[self.id].npc_info) do 
				self.npc_info[id] = v
			end 
			
			self.dead_time = m_data.smart_terrains[self.id].dead_time
			self.already_spawned = m_data.smart_terrains[self.id].already_spawned
			self.last_respawn_update = m_data.smart_terrains[self.id].last_respawn_update
		end
		return 
	end
	-- ïîä LevelEditor íå ïûòàòüñÿ ÷èòàòü èç ïàêåòà íè÷åãî
	if editor() then
		return
	end

	--set_save_marker(packet, "load", false, "se_smart_terrain")

	-- Èíôîðìàöèþ î ÍÏÑ, èäóùèõ â ñìàðò
	local n = packet:r_u8()
	self.arriving_npc = {}
	for i = 1,n do
		local id = packet:r_u16()
		if (id < 65535) then
			self.arriving_npc[id] = false
		end
	end

	n = packet:r_u8()

	local id
	for i = 1,n do
		id = packet:r_u16()
		self.npc_info[id] = {}
		self.npc_info[id].job_section = packet:r_stringZ()
		self.npc_info[id].begin_job = packet:r_bool()
		self.npc_info[id].need_job = packet:r_stringZ()
	end

	if (self.npc_info[65535]) then
		printf("%s:STATE_Read: invalid id in npc_info table. Check for save corruption or error in smart_terrain job system.")
		self.npc_info[65535] = nil
	end

	n = packet:r_u8()

	empty_table(self.dead_time)

	for i =1,n do
		local sec = packet:r_stringZ()
		local gt = utils.r_CTime(packet)
		if (sec and sec ~= "nil" and sec ~= "") then
			self.dead_time[sec] = gt
		end
	end

	local respawn_point = packet:r_bool()
	--printf("LOAD RESPAWN %s", self:name())
	if respawn_point then
		n = packet:r_u8()
		for i = 1, n do
			local id = packet:r_stringZ()
			local num = packet:r_u8()
			if (id and id ~= "nil" and id ~= "") then
				self.already_spawned[id].num = num
			end
		end
		self.last_respawn_update = utils.r_CTime(packet)
	end

	--set_save_marker(packet, "load", true, "se_smart_terrain")
	--alun_utils.debug_write(strformat("%s:STATE_READ end",self:name()))
end

-- Setup NPC jobs from loaded savegames. Use unique ids generated
-- by the gulag_general.script for each smart job to retake job
function se_smart_terrain:init_npc_after_load()
	if (self.disabled) then
		return
	end

	local sim = alife()

	-- Here we setup arriving npcs from loaded savegame
	-- throw out invalid object ids
	for id,v in pairs(self.arriving_npc) do
		self.arriving_npc[id] = sim:object(id) or nil
	end
	
	local sobj

	-- validate and fill saved npc_info; find job by saved uid
	local new_info
	for id, info in pairs(self.npc_info) do
		sobj = sim:object(id)
		local cls = sobj and sobj:clsid()
		if (cls) and (IsStalker(nil,cls) or IsMonster(nil,cls) or IsHelicopter(nil,cls)) then
			new_info = self:fill_npc_info(sobj)
			new_info.job = self:find_job_by_section(info.job_section)

			if (new_info.job) then
				self.npc_by_job_section[new_info.job.section] = id
				new_info.begin_job = info.begin_job
				new_info.need_job = info.need_job
			end

			self.npc_info[id] = new_info
		else
			self.npc_info.job = self:find_job_by_section(info.job_section)
			self:clear_job(id,true)
		end
	end
end

function se_smart_terrain:stayed_squad_count()
	local smrt = SIMBOARD.smarts[self.id]
	if (smrt) then
		local count = 0
		for k,squad in pairs(smrt.squads) do
			if (squad and squad.current_target_id and squad.current_target_id == self.id) then
				count = count + 1
			end
		end
		return count
	end
	return 0
end 

function se_smart_terrain:get_smart_props()
	if (self.disabled) then
		return "deactivated\\n\\n"..self:name().."  ["..self.id.."]\\n"..self.sim_type.."\\n".."squad_id = "..tostring(self.id)
	end

	local props = (not self.disabled) and smart_names.get_smart_terrain_name(self)
	if(props==nil) or (DEV_DEBUG and axr_main.config:GetValue("mm_options","enable_debug_hud",1,false) == true) then
		if (self.disabled) then
			return "deactivated\\n\\n"..self:name().."  ["..self.id.."]\\n"..self.sim_type.."\\n".."squad_id = "..tostring(self.id)
		end

		local board = SIMBOARD
		local squad_count = board.smarts[self.id].population --smart_terrain_squad_count(board.smarts[self.id].squads)
		
		props = self:name().."  ["..self.id.."]\\n"
		
		if (self.faction_controlled) then 
			props = props .. "faction_controlled = " .. tostring(self.faction_controlled) .. "\\n"
		end 
		
		props = props .. "controlling_faction = ".. tostring(self.faction) .. "\\n"..self.sim_type.."\\n".."squad_id = "..tostring(self.id).."\\n".."capacity = "..squad_count.." of "..tostring(self.max_population).."\\n"

		if self.respawn_point ~= nil and self.already_spawned ~= nil then
			props = props.."\\nalready_spawned :\n"
			for k,v in pairs(self.already_spawned) do
				props = props.."["..k.."] = "..v.num.."("..xr_logic.pick_section_from_condlist(db.actor, nil,self.respawn_params[k].num)..")\\n"
			end
			if self.last_respawn_update then
				props = props.."\\ntime_to_spawn:"..tostring(self.respawn_idle - game.get_game_time():diffSec(self.last_respawn_update)).."\\n"
			end
		end

		--' Äîáàâëÿåì èíôîðìàöèþ î íàõîäÿùèõñÿ â ñìàðòå îòðÿäàõ
		for k,v in pairs(SIMBOARD.smarts[self.id].squads) do
			props = props .. tostring(v.id) .. "\\n"
		end

		if (self.props) then
			for prop,val in pairs(self.props) do 
				if (val > 0) then 
					props = props .. prop .. " = " .. val .. "\\n"
				end
			end 
		end
		
		props = props .. "\\nstayed_squad_count = " .. tostring(self:stayed_squad_count())
	end
	return props
end

function se_smart_terrain:show()
	local tg = time_global()
	if(self.showtime~=nil) and (self.showtime+200>=tg) then
		return
	end
	self.showtime = tg

	local player = self.player_name
	local spot = "neutral"

	if self.sim_avail == nil or xr_logic.pick_section_from_condlist(db.actor or alife():actor(), self, self.sim_avail) == "true" then
		spot = "friend"
	else
		spot = "enemy"
	end

	local level = level
	if(self.smrt_showed_spot==spot) then
		level.map_change_spot_hint(self.id, "alife_presentation_smart_"..self.sim_type.."_"..self.smrt_showed_spot, self:get_smart_props())
		return
	end

	if (DEV_DEBUG and axr_main.config:GetValue("mm_options","enable_debug_hud",1,false) == true) then
		if(self.smrt_showed_spot~=nil) then
			level.map_remove_object_spot(self.id, "alife_presentation_smart_"..self.sim_type.."_"..self.smrt_showed_spot)
		end
		level.map_add_object_spot(self.id, "alife_presentation_smart_"..self.sim_type.."_"..spot, self:get_smart_props())
		self.smrt_showed_spot = spot
	else
		if(self.smrt_showed_spot~=nil) and (level.map_has_object_spot(self.id, "alife_presentation_smart_"..self.sim_type.."_"..self.smrt_showed_spot)~=0) then
			level.map_remove_object_spot(self.id, "alife_presentation_smart_base_"..self.smrt_showed_spot)
		end
	end
end

function se_smart_terrain:hide()
	if self.smrt_showed_spot == nil then
		return
	end
	level.map_remove_object_spot(self.id, "alife_presentation_smart_"..self.sim_type.."_"..self.smrt_showed_spot)
end

local function is_only_monsters_on_jobs(npc_info)
	local pairs = pairs
	for k,v in pairs(npc_info) do
		if not (v.stype == 1) then
			return false
		end
	end
	return true
end

local function is_monster_on_job(npc_info)
	local pairs = pairs
	for k,v in pairs(npc_info) do
		if (v.stype == 1) then
			return true
		end
	end
	return false	
end

function se_smart_terrain:update()
	cse_alife_smart_zone.update( self )

	if (DEV_DEBUG and axr_main.config:GetValue("mm_options","enable_debug_hud",1,false) == true) then
		self:show()
	end
	
	if (self.disabled) then
		return
	end
	
	--alun_utils.debug_write(strformat("%s:update ",self:name()))
	


	-- delta
	local tg = time_global()
	if (self.check_time and tg < self.check_time) then
		return
	end
	
	local sim = alife()
	local se_actor = sim:actor()
	local dist_to_actor = self.position:distance_to(se_actor.position)
	
	if self.respawn_params ~= nil then
		self:try_respawn(dist_to_actor)
	end
	
	simulation_objects.get_sim_obj_registry():update_avaliability(self)
	
	if (self.is_on_actor_level) then
		local old_dist_to_actor = (nearest_to_actor_smart.id == nil and nearest_to_actor_smart.dist) or sim:object(nearest_to_actor_smart.id).position:distance_to(se_actor.position)
		if dist_to_actor < old_dist_to_actor then
			nearest_to_actor_smart.id = self.id
			nearest_to_actor_smart.dist = dist_to_actor
		end
		
		-- check time
		if (nearest_to_actor_smart and nearest_to_actor_smart.id == self.id) then 
			nearest_to_actor_smart.dist = dist_to_actor
			self.check_time = tg+500
		else 
			self.check_time = tg+3000 + math.max(500, 0.025*dist_to_actor)
		end
		
		if (self.__campfire_check_time == nil or game.get_game_time():diffSec(self.__campfire_check_time) > 12000) then
			--if (is_only_monsters_on_jobs(self.npc_info)) then
				bind_campfire.turn_off_campfires_by_smart_name(self:name())
				self.__campfire_check_time = game.get_game_time()
			--end
		end

	else
		-- check time
		self.check_time = tg + 15000 + math.random(1000,5000)
	end

	local gt = game.get_game_time()
	for k,v in pairs(self.dead_time) do
		if (gt:diffSec(v) >= self.death_idle_time) then
			self.dead_time[k] = nil
		end
	end

	self:update_jobs()
end

function se_smart_terrain:set_alarm()
	self.smart_alarm_time = game.get_game_time()
end

function se_smart_terrain:check_alarm()
	if self.smart_alarm_time == nil then
		return false
	end
	if game.get_game_time():diffSec(self.smart_alarm_time) > 5 then
		self.smart_alarm_time = nil
		return false
	end
	return true
end

function se_smart_terrain:find_job_by_section(section)
	if (self.disabled) then
		return
	end
	
	if (self.stalker_jobs) then
		for i=1,#self.stalker_jobs do
			if (self.stalker_jobs[i].section == section) then
				return self.stalker_jobs[i]
			end
		end
	end 
	
	if (self.monster_jobs) then
		for i=1,#self.monster_jobs do
			if (self.monster_jobs[i].section == section) then
				return self.monster_jobs[i]
			end
		end
	end
	
	if (self.heli_jobs) then 
		for i=1,#self.heli_jobs do
			if (self.heli_jobs[i].section == section) then
				return self.heli_jobs[i]
			end
		end
	end
end

-- called in xr_motivator and bind_monster net_spawn()
function setup_gulag_and_logic_on_spawn(obj, st, se_obj, stype, loaded)
	--alun_utils.debug_write(strformat("smart_terrain.setup_gulag_and_logic_on_spawn %s",obj and obj:name()))
	local sim = alife()
	local smart = se_obj.m_smart_terrain_id and se_obj.m_smart_terrain_id ~= 65535 and sim:object(se_obj.m_smart_terrain_id)
	local npc_info = smart and smart.npc_info and smart.npc_info[se_obj.id]
	if (npc_info) then
		npc_info.begin_job = false
	end
	xr_logic.initialize_obj(obj, st, loaded, db.actor, stype)
end

function on_death(se_obj)
	local sim = alife()
	local smart = sim and se_obj.m_smart_terrain_id and se_obj.m_smart_terrain_id ~= 65535 and sim:object(se_obj.m_smart_terrain_id)
	if (smart) then 
		smart:clear_dead(se_obj)
	end
end

--***********************************************************************************************
--*										SIMULATION_TARGET_SMART									*
--***********************************************************************************************
function se_smart_terrain:get_location()
	return self.position, self.m_level_vertex_id, self.m_game_vertex_id
end

function se_smart_terrain:am_i_reached(squad)
	if (squad.m_game_vertex_id == self.m_game_vertex_id) then 
		return true 
	end 
	
	local gg = game_graph()
	if (gg:vertex(squad.m_game_vertex_id):level_id() ~= gg:vertex(self.m_game_vertex_id):level_id()) then
		return false
	end
	
	-- TODO: Maybe consider to return true if squad:get_script_target() is true
	if (is_squad_monster[squad.player_id] and squad:get_script_target() == nil) then 
		return squad.position:distance_to_sqr(self.position) <= 625
	end

	return squad.always_arrived == true or squad.position:distance_to_sqr(self.position) <= self.arrive_dist^2
end

function se_smart_terrain:on_after_reach(squad)
	local sim = alife()
	local se_obj
	for k in squad:squad_members() do
		se_obj = k.object or k.id and sim:object(k.id)
		if (se_obj) then
			SIMBOARD:setup_squad_and_group(se_obj)
		end
	end
	squad.current_target_id = self.id
end

function se_smart_terrain:on_reach_target(squad)
	--alun_utils.debug_write(strformat("%s:on_reach_target %s",self:name(),squad and squad:name()))
	squad:set_location_types(self:name())
	SIMBOARD:assign_squad_to_smart(squad, self.id)
	for k in squad:squad_members() do
		if db.offline_objects[k.id] ~= nil then
			empty_table(db.offline_objects[k.id])
		end
	end
end

-- CALifeSmartTerrainTask
function se_smart_terrain:get_alife_task()
	return self.smart_alife_task
end

function smart_terrain_squad_count(board_smart_squads)
	local count = 0
	local pairs = pairs
	for k,v in pairs(board_smart_squads) do
		if v:get_script_target() == nil then
			count = count + 1
		end
	end
	return count
end

function se_smart_terrain:sim_available()
	return true
end

function surge_stats()
end

function se_smart_terrain:target_precondition(squad, ignore_population)
	--alun_utils.debug_write(strformat("%s:target_precondition",squad and squad:name()))
	if self.respawn_only_smart == true then
		return false
	end

	-- squad is already stayed here don't count population
	if not (ignore_population) then
		local squad_count = SIMBOARD.smarts[self.id].population -- smart_terrain_squad_count(SIMBOARD.smarts[self.id].squads)
		if (squad_count and squad_count >= self.max_population) then
			return false
		end
	end
	
	if not (self.props) then 
		return false
	end
	
	if (self.props[squad.player_id] == nil or self.props.all > 0 or self.props[squad.player_id] > 0) then
		
		local is_monster = is_squad_monster[squad.player_id]
		if (is_monster ~= true and squad.player_id ~= "zombied") then
			-- surge
			if (xr_conditions.surge_started()) then
				if (self.props.surge > 0) then 
					return true 
				end
				return false
			end
			
			-- base
			if (self.props.base > 0 and sim_board.general_base_precondition(squad,self)) then 
				return true 
			end
			
			-- resource
			if (self.props.resource > 0 and sim_board.general_resource_precondition(squad,self)) then 
				return true 
			end
		else
			-- lair
			if (self.props.lair > 0 and sim_board.general_lair_precondition(squad,self)) then 
				return true 
			end
		end
		
		-- territory
		if (self.props.territory > 0 and sim_board.general_territory_precondition(squad,self)) then 
			return true 
		end
	end

	return false
end

function se_smart_terrain:evaluate_prior(squad)
	return simulation_objects.evaluate_prior(self, squad)
end

local available_sects = {}
function se_smart_terrain:try_respawn(dist_to_actor)
	if (self.disabled) then
		return
	end
	if (has_alife_info("actor_made_wish_for_peace")) then 
		return 
	end
	
	--alun_utils.debug_write(strformat("%s:try_respawn",self:name()))
	
	if (dist_to_actor < self.respawn_radius) then
		return
	end
		
	if self.sim_avail ~= nil and xr_logic.pick_section_from_condlist(db.actor, self, self.sim_avail) ~= "true" then return end
	local curr_time = game.get_game_time()
	
	if (is_monster_on_job(self.npc_info)) then
		local squad_count = smart_terrain_squad_count(SIMBOARD.smarts[self.id].squads)
		if self.max_population <= squad_count then
			return
		end
	end
	
	if self.last_respawn_update == nil or curr_time:diffSec(self.last_respawn_update) > self.respawn_idle then
		self.last_respawn_update = curr_time
		
		clear_table(available_sects)
		
		-- check self.faction
		if not (self.faction) then 
			self.faction = utils.cfg_get_string(self.ini, "smart_terrain", "default_faction",self, false,"")
		end
				
		for k,v in pairs(self.respawn_params) do
			if (self.faction_controlled == nil) or (self.faction ~= nil and v.faction == self.faction) then 
				if tonumber(xr_logic.pick_section_from_condlist(db.actor, self,v.num)) > self.already_spawned[k].num then
					table.insert(available_sects,k)
				end
			end
		end
		
		if #available_sects > 0 then
			local sect_to_spawn = available_sects[math.random(1,#available_sects)]
			local sect_to_spawn_params = self.respawn_params[sect_to_spawn]
			
			if (sect_to_spawn_params.squads) then
				local squad = has_alife_info("actor_made_wish_for_control") and SIMBOARD:create_squad(self, "simulation_controller_psy") or SIMBOARD:create_squad(self, sect_to_spawn_params.squads[math.random(1,#sect_to_spawn_params.squads)])
				if (squad) then
					squad.respawn_point_id = self.id
					squad.respawn_point_prop_section = sect_to_spawn
					for m in squad:squad_members() do
						SIMBOARD:setup_squad_and_group(m.object)
					end
				else
					printf("call respawn failed for %s, check squad descriptions",sect_to_spawn)
					return
				end
			elseif (sect_to_spawn_params.helicopter) then
				local heli = sect_to_spawn_params.helicopter[math.random(1,#sect_to_spawn_params.helicopter)]
				if (heli) then --if (heli and self.is_on_actor_level) then
					local pos = vector():set(self.position.x,self.position.y+30,self.position.z)
					local lvid = self.m_level_vertex_id
					local gvid = self.m_game_vertex_id
					
					local path = self.smart_level.."_heli_hide"
					if (level.patrol_path_exists(path)) then 
						local pat = patrol(path)
						pos = pat:point(0)
					end
					
					local se_heli = alife():create(heli,pos,lvid,gvid)
					
					local visual = utils.cfg_get_string(system_ini(),heli,"visual",se_heli,false)
					-- required to spawn by script
					local data = stpk_utils.get_heli_data(se_heli)
					if (data) then
						data.visual_name = visual and visual ~="" and visual or [[dynamics\vehicles\mi2\veh_mi2_01]]
						data.motion_name = [[helicopter\aaa.anm]]
						data.startup_animation = "idle"
						data.skeleton_name = "idle"
						data.engine_sound = [[vehicles\helicopter\helicopter]]
						stpk_utils.set_heli_data(data,se_heli)
						
						self:register_npc(se_heli)
						se_heli.respawn_point_id = self.id
						se_heli.respawn_point_prop_section = sect_to_spawn
					else
						alife():release(se_heli,true)
					end
				else
					return
				end
			end
			self.already_spawned[sect_to_spawn].num = self.already_spawned[sect_to_spawn].num + 1
		end
	end
end

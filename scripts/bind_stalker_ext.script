--[[
	bind_stalker_ext.script
	
	Extends the functionality of bind_stalker.script without filling it with clutter
	
	by: Alundaio
--]]

-------------------
-- actor_on_init
-------------------
function actor_on_init(binder)
	SendScriptCallback("actor_on_init",binder)
end 

-------------------
-- actor_on_net_spawn
-------------------
function actor_on_net_spawn()

	-- Uncomment to remove all corpses at beginning of game in case they cause error
	--[[
	local sim = alife()
	local se_obj
	for i=1,65534 do 
		se_obj = sim:object(i)
		if (se_obj and (se_obj:clsid() == clsid.script_stalker or IsMonster(nil,se_obj:clsid())) and not se_obj:alive()) then 
			sim:release(se_obj,true)
		end
	end
	--]]
	
	if (axr_main.config:GetValue("mm_options","enable_heli_spawn",1,true) == false) then 
		for k,v in pairs(se_heli.se_helicopters) do 
			alife():release(v,true)
		end
	end
	
	SendScriptCallback("on_game_load",binder)
end

-------------------------------------
-- actor_on_net_destroy
-------------------------------------
function actor_on_net_destroy(binder)
	SendScriptCallback("actor_on_net_destroy",binder)
end 

-------------------
-- actor_on_update
-------------------
function actor_on_first_update(binder,delta)
	SendScriptCallback("actor_on_first_update",binder,delta)
end

actor_light = nil
function actor_on_update(binder,delta)
	local tg = time_global()
	
	-- evaluate event queue
	ProcessEventQueue()

	-- Check HudMsg
	if (ShowMessageTime) then
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("not_enough_money_mine")
		if custom_static ~= nil and tg > ShowMessageTime then
			hud:RemoveCustomStatic("not_enough_money_mine")
			ShowMessageTime = nil
		end
	end

	-- WISH GRANTER ZOMBIED-IMMORTALITY
	if (db.actor:has_info("actor_made_wish_immortal")) then 
		db.actor.health = 1
		db.actor.bleeding = 1
		db.actor.psy_health = 1
		db.actor.radiation = -1
	end
	
	local torch = db.actor:object("device_torch")
	if (torch and not actor_light and torch:torch_enabled()) then
		actor_light = true
		SendScriptCallback("actor_on_torch_enabled")
	elseif (torch and not torch:torch_enabled()) then
		if (actor_light) then
			actor_light = false
			SendScriptCallback("actor_on_torch_disabled")
		end
	end
	
	--[[ Prevents actor from falling below map (works just commented out because not needed)
	local vid = db.actor:level_vertex_id()
	last_valid_vertex_id = vid < 4294967295 and vid
	
	if not (level_min_y) then 
		level_min_y = level.get_bounding_volume().min.y
	end
	
	if (db.actor:position().y < level_min_y) then 
		if (last_valid_vertex_id) then
			db.actor:set_actor_position(level.vertex_position(last_valid_vertex_id))
		end
	end
	--]]
	
	SendScriptCallback("actor_on_update",binder,delta)
end

-------------------
-- actor_on_weapon_no_ammo(wpn)
-------------------
-- TODO: add in engine
function actor_on_weapon_no_ammo(binder,wpn)
	SendScriptCallback("actor_on_weapon_no_ammo",wpn)
end

-------------------
-- actor_on_weapon_zoom_in(wpn)
-------------------
function actor_on_weapon_zoom_in(binder,obj,wpn)
	SendScriptCallback("actor_on_weapon_zoom_in",wpn)
end

-------------------
-- actor_on_weapon_zoom_out(wpn)
-------------------
function actor_on_weapon_zoom_out(binder,obj,wpn)
	SendScriptCallback("actor_on_weapon_zoom_out",wpn)
end

-------------------
-- actor_on_item_take(item)
-------------------
function actor_on_item_take(binder,item)
	if not (db.actor) then 
		return -- don't remove, for some reason this callback is triggered before actor is fully loaded
	end
	--treasure_manager.get_treasure_manager():on_item_take(item:id()) -- disabled for coc
	SendScriptCallback("actor_on_item_take",item)
end

-------------------
-- actor_on_item_take_from_box
-------------------
function actor_on_item_take_from_box(binder,box,item)
	SendScriptCallback("actor_on_item_take_from_box",box,item)
end

-------------------
--
-------------------
function actor_on_item_drop(binder,item)
	SendScriptCallback("actor_on_item_drop",item)
end 

-------------------
-- actor_on_item_use(item)
-------------------
function actor_on_item_use(binder,item)
	local sec = item:section()
	if (sec == "drug_anabiotic") then 
		xr_effects.disable_ui_only(db.actor, nil)
		level.add_cam_effector("camera_effects\\surge_02.anm", 10, false, "bind_stalker_ext.anabiotic_callback")
		level.add_pp_effector("surge_fade.ppe", 11, false)
		give_info("anabiotic_in_process")
		local con = get_console()
		_G.mus_vol = con:get_float("snd_volume_music")
		_G.amb_vol = con:get_float("snd_volume_eff")
		con:execute("snd_volume_music 0")
		con:execute("snd_volume_eff 0")
	elseif (sec == "drug_psy_blockade" or sec == "drug_radioprotector" or sec == "drug_antidot") then
		local boost_time = system_ini():r_float_ex(sec,"boost_time")
		xr_logic.pstor_store(db.actor,sec.."_expiration",utils.CTimeAddSec(game.get_game_time(),boost_time*level.get_time_factor()))
	elseif (sec == "radio_connections_pda") then 
		run_dynamic_element(pda_dialog.pda_dialog_box(),true)
	end 
	SendScriptCallback("actor_on_item_use",item,sec)
end

-------------------
-- actor_on_trade(item)
-------------------
function actor_on_trade(binder,item,sell_bye,money)
	if sell_bye == true then
		 game_stats.money_trade_update (money)
	else
		 game_stats.money_trade_update (-money)
	end
	SendScriptCallback("actor_on_trade",item,sell_bye,money)
end

-------------------
-- actor_on_save(bind_stalker,packet)
-- IMPORTANT: Cannot be used as callback because this needs to be done in specific order, just call script directly!
-------------------
function actor_on_save(binder,packet)
	local sim,gg = alife(),game_graph()
	local actor_gv = sim and gg:vertex(sim:actor().m_game_vertex_id)
	
	if (actor_gv and actor_gv:level_id() ~= sim:level_id()) then
		--printf("DEBUG: actor changing level")
		SendScriptCallback("on_level_changing")
	end

	if (coc_treasure_manager) then
		coc_treasure_manager.save(packet)
	end
	
	surge_manager.actor_on_save(binder,packet)
	psi_storm_manager.actor_on_save(binder,packet)
end

-------------------
-- actor_on_load(bind_stalker,packet)
-- IMPORTANT: Cannot be used as callback because this needs to be done in specific order, just call script directly!
-------------------
function actor_on_load(binder,packet)
	if (coc_treasure_manager) then
		coc_treasure_manager.load(packet)
	end
	surge_manager.actor_on_load(binder,packet)
	psi_storm_manager.actor_on_load(binder,packet)
end

---------------------------------------------
-- on_key_press
---------------------------------------------
function on_key_press(binder,key)
	SendScriptCallback("on_key_press",key)
end

---------------------------------------------
-- on_key_release
---------------------------------------------
function on_key_release(binder,key)
	SendScriptCallback("on_key_release",key)
end

---------------------------------------------
-- on_key_hold
---------------------------------------------
function on_key_hold(binder,key)
	SendScriptCallback("on_key_hold",key)
end

---------------------------------------------
-- on_actor_before_death
---------------------------------------------
function actor_on_before_death(binder,whoID)
	-- if you want to keep actor alive, then use db.actor:set_health_ex(1) and do not use db.actor:kill(db.actor,true)
	--db.actor:set_health_ex(1)
	
	-- This is necessary to avoid engine crash when player dies with holder
	local car = db.actor and db.actor:get_attached_vehicle()
	if (car) then 
		db.actor:detach_vehicle()
	end
	
	db.actor:kill(db.actor, true)
	
	SendScriptCallback("actor_on_before_death",whoID)
end

---------------------------------------------
-- on_attach_vehicle
---------------------------------------------
function actor_on_attach_vehicle(binder,obj)
	SendScriptCallback("actor_on_attach_vehicle",obj)
end

---------------------------------------------
-- on_detach_vehicle
---------------------------------------------
function actor_on_detach_vehicle(binder,obj)
	SendScriptCallback("actor_on_detach_vehicle",obj)
end

---------------------------------------------
-- 	on_use_vehicle
---------------------------------------------
function actor_on_use_vehicle(binder,obj)
	SendScriptCallback("actor_on_use_vehicle",obj)
end

---------------------------------------------
--	actor_on_task_callback
---------------------------------------------
function actor_on_task_callback(binder,_task, _state)
	if _state ~= task.fail then
		if _state == task.completed then
			news_manager.send_task(db.actor, "complete", _task)
		else
			news_manager.send_task(db.actor, "new", _task)
		end
	end
	task_manager.task_callback(_task, _state)
end

------------------------------------------
-- anabiotic_callback
------------------------------------------
function anabiotic_callback()
	level.add_cam_effector("camera_effects\\surge_01.anm", 10, false, "bind_stalker_ext.anabiotic_callback2")
	local rnd = math.random(35,45)
	local m = surge_manager.SurgeManager
	if(m.started) then
		local tf = level.get_time_factor()
		local diff_sec = math.ceil(game.get_game_time():diffSec(m.inited_time)/tf)
			if(rnd>(m.surge_time-diff_sec)*tf/60) then
			m.time_forwarded = true
			m.ui_disabled = true
			m:kill_all_unhided()
			m:end_surge()
		end
	end
	m = psi_storm_manager and psi_storm_manager.PsiStormManager
	if(m and m.started) then
		local tf = level.get_time_factor()
		local diff_sec = math.ceil(game.get_game_time():diffSec(m.inited_time)/tf)
			if(rnd>(m.psi_storm_duration-diff_sec)*tf/60) then
			m.time_forwarded = true
			--m.ui_disabled = true
			m:finish()
		end
	end
	level.change_game_time(0,0,rnd)
	level_weathers.get_weather_manager():forced_weather_change()
	--printf("anabiotic_callback: time forwarded on [%d]", rnd)
end

function anabiotic_callback2()
	xr_effects.enable_ui(db.actor, nil)
    get_console():execute("snd_volume_music "..tostring(_G.mus_vol))
	get_console():execute("snd_volume_eff "..tostring(_G.amb_vol))
	_G.amb_vol = 0
	_G.mus_vol = 0
	disable_info("anabiotic_in_process")
end

function actor_on_info_callback(binder,obj,info_id)
	SendScriptCallback("actor_on_info_callback",obj,info_id)
	--printf("info_id = %s",info_id)
end

function actor_item_to_belt(binder,obj)

end 

function actor_item_to_slot(binder,obj)
	if (axr_main.config:GetValue("mm_options","enable_outfit_portrait",1,false) == true) then
		local outfit = db.actor:item_in_slot(7)
		if (outfit and outfit:id() == obj:id()) then 
			local icon = system_ini():r_string_ex(outfit:section(),"character_icon")
			if (icon) then 
				db.actor:set_character_icon(icon)
			elseif (db.actor_binder.character_icon) then -- use default portrait if no outfit portrait exists
				db.actor:set_character_icon(db.actor_binder.character_icon)
			end
		end
	end
end 

function actor_item_to_ruck(binder,obj)
    if IsOutfit(obj) and (axr_main.config:GetValue("mm_options","enable_outfit_portrait",1,false) == true) then
        local outfit = db.actor:item_in_slot(7)
        if (outfit == nil and db.actor_binder.character_icon) then
            db.actor:set_character_icon(db.actor_binder.character_icon)
        end
    end
end

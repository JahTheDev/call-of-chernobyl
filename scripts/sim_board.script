--'******************************************************
--'*Registry of smart terrains. The playing field simulation.
-- Edited by Alundaio
--'******************************************************
-------------------
local level,alife,game_graph,math,pairs,tostring,tonumber,tsort,tinsert = level,alife,game_graph,math,pairs,tostring,tonumber,table.sort,table.insert
-------------------
-----------------------------------------------------------------------------------
--						Public
-----------------------------------------------------------------------------------
function general_squad_precondition(squad,target)
	-- duty and freedom target eachother
	--[[
	if (squad.player_id == "dolg") then 
		if (target.player_id == "freedom" or is_squad_monster[target.player_id]) then 
			return in_time_interval(8,19)
		end
	elseif (squad.player_id == "freedom") then 
		if (target.player_id == "dolg") then 
			return in_time_interval(8,19)
		end 
	end
	--]]
	
	-- if target squad is not monster
	if (is_squad_monster[target.player_id] ~= true) then 
		if (squad.player_id == "monster_predatory_day") then 
			return in_time_interval(6,19)
		elseif (squad.player_id == "monster_predatory_night") then 
			return in_time_interval(19,6)
		elseif (squad.player_id == "monster_zombied_day") then 
			return in_time_interval(6,19)
		elseif (squad.player_id == "monster_zombied_night") then 
			return in_time_interval(19,6)
		end
	end 
	return false
end

function general_base_precondition(squad,target)
	local need_squads = 0
	
	if (squad.player_id == "dolg") then 
		if (target.faction == "freedom") then
			need_squads = 1
		end
	elseif (squad.player_id == "freedom") then 
		if (target.faction == "dolg") then
			need_squads = 1
		end	
	elseif (squad.player_id == "army") then 
		if (target.faction_controlled and target.faction == "army") then 
			need_squads = 2
		else
			need_squads = 1
		end
	elseif (squad.player_id == "monolith") then 
		if (target.faction_controlled and target.faction ~= "monolith") then 
			need_squads = 1
		end
	elseif (squad.player_id == "stalker" or squad.player_id == "csky") then 
		need_squads = 2
	elseif (squad.player_id == "bandit") then
		if (target.faction_controlled and target.faction ~= "bandit") then 
			need_squads = 2
		end
	end
	
	if need_squads > target.max_population then
		need_squads = target.max_population
	end
	
	if (SIMBOARD.smarts[target.id]) and (SIMBOARD.smarts[target.id].squads[squad.id] or SIMBOARD.smarts[target.id].population < target.max_population and SIMBOARD.smarts[target.id].population < need_squads) then
		return true
	end

	return in_time_interval(6,10)
end

function general_territory_precondition(squad,target)
	if (squad.player_id == "monster_predatory_day") then 
		return in_time_interval(6,19)
	elseif (squad.player_id == "monster_predatory_night") then 
		return in_time_interval(19,6)
	elseif (squad.player_id == "monster_zombied_day") then 
		return in_time_interval(6,19)
	elseif (squad.player_id == "monster_zombied_night") then 
		return in_time_interval(19,6)
	elseif (squad.player_id == "monster_vegetarian" or squad.player_id == "zombied") then 
		return true
	end
	return in_time_interval(10,6)
end

function general_resource_precondition(squad,target)
	return in_time_interval(10,6)
end

function general_lair_precondition(squad,target)
	--[[
	if (squad.player_id == "monster_predatory_day") then 
		return in_time_interval(19,6)
	elseif (squad.player_id == "monster_predatory_night") then 
		return in_time_interval(6,19)
	elseif (squad.player_id == "monster_zombied_day") then 
		return in_time_interval(19,6)
	elseif (squad.player_id == "monster_zombied_night") then 
		return in_time_interval(6,19)
	elseif (squad.player_id == "monster_vegetarian" or squad.player_id == "zombied") then 
		return true
	end 
	return in_time_interval(19,6)
	--]]
	return true -- Will fill up all the lairs first, by monster squads
end

--------------------------------------------------------------------------------------------------------
--					SIMULATION BOARD
--------------------------------------------------------------------------------------------------------

class "simulation_board"
function simulation_board:__init()
	--' smart = {smrt, targets = {}, dangers = {}, squads = {}, stayed_squads = {}}
	self.smarts = {}
	self.smarts_by_names = {}
	self.simulation_started = true
	self.squads = {}
	self.tmp_assigned_squad = {}
end

function simulation_board:register_smart(obj)
	--alun_utils.debug_write(strformat("simulation_board:register_smart %s",obj and obj:name()))
	if self.smarts[obj.id] ~= nil then
		printf("Smart already exist in list [%s]", obj:name())
		return
	end

	--self.smarts[obj.id] = {smrt = obj, squads = {}, stayed_squads = {}, population = 0}
	self.smarts[obj.id] = {smrt = obj, squads = {}, population = 0}
	self.smarts_by_names[obj:name()] = obj
end

function simulation_board:unregister_smart(obj)
	--alun_utils.debug_write(strformat("simulation_board:unregister_smart %s",obj and obj:name()))
	self.smarts[obj.id] = nil
	self.smarts_by_names[obj:name()] = nil
end

function simulation_board:start_sim() -- Doesn't seem to be used in 1.6
	self.simulation_started = true
end

function simulation_board:stop_sim() -- Doesn't seem to be used in 1.6
	self.simulation_started = false
end

function simulation_board:set_actor_community(community)
	---- Устанавливаем группировку игрока
	db.actor:set_character_community(actor_communitites[community], 0, 0)
end

-- Инициализация смарта
function simulation_board:init_smart(obj)
	--alun_utils.debug_write(strformat("simulation_board:init_smart %s",obj and obj:name()))
	if self.tmp_assigned_squad[obj.id] ~= nil then
		for k,v in pairs(self.tmp_assigned_squad[obj.id]) do
			self:assign_squad_to_smart(v, obj.id)
		end
		self.tmp_assigned_squad[obj.id] = nil
	end
end

--' Создание нового отряда
function simulation_board:create_squad(spawn_smart, sq_id)
	--alun_utils.debug_write(strformat("simulation_board:create_squad spawn_smart=%s sq_id=%s",spawn_smart and spawn_smart:name(),sq_id))
	local squad_id = tostring(sq_id)
	if not (system_ini():section_exist(squad_id)) then
		printf("squad section does not exist: %s",squad_id)
		return
	end

	local squad = alife():create(squad_id,spawn_smart.position,	spawn_smart.m_level_vertex_id,spawn_smart.m_game_vertex_id)
	squad:create_npc(spawn_smart)
	squad:set_squad_relation()
	self:assign_squad_to_smart(squad, spawn_smart.id)

	local se_obj
	local sim = alife()
	for k in squad:squad_members() do
		se_obj = k.object or k.id and sim:object(k.id)
		if (se_obj) then
			SIMBOARD:setup_squad_and_group(se_obj)
			-- Alundaio
			SendScriptCallback("squad_on_npc_creation",squad,se_obj,spawn_smart)
			-- Alundaio
		end
    end
	return squad
end
--' Удалить отряд

function simulation_board:remove_squad(squad)
	--alun_utils.debug_write(strformat("simulation_board:remove_squad %s",squad and squad:name()))

	self:assign_squad_to_smart(squad, nil)

	squad:remove_squad()
end
--' Назначение отряда в смарт.
function simulation_board:assign_squad_to_smart(squad, smart_id)
	--alun_utils.debug_write(strformat("simulation_board:assign_squad_to_smart %s smart_id=%s",squad and squad:name(),smart_id))

	if (smart_id and self.smarts[smart_id] == nil) then
		if self.tmp_assigned_squad[smart_id] == nil then
			self.tmp_assigned_squad[smart_id] = {}
		end
		table.insert(self.tmp_assigned_squad[smart_id], squad)
		return
	end
	
	local old_smart_id = squad.smart_id
	squad.smart_id = nil
	
	-- remove squad from old smart if exist
	if (old_smart_id and self.smarts[old_smart_id] and self.smarts[old_smart_id].squads[squad.id]) then
		self.smarts[old_smart_id].squads[squad.id] = nil
		
		-- get accurate population count excluding squads using target_smart param
		self.smarts[old_smart_id].population = smart_terrain.smart_terrain_squad_count(SIMBOARD.smarts[old_smart_id].squads)
	end

	if smart_id == nil then
		squad:assign_smart(nil,old_smart_id)
		return
	end

	squad:assign_smart(self.smarts[smart_id].smrt,old_smart_id)

	--' Прописываем отряд в новом смарте.
	if not (self.smarts[smart_id].squads[squad.id]) then
		self.smarts[smart_id].squads[squad.id] = squad
		if not (squad:get_script_target()) then
			-- don't count squads with target_smart
			self.smarts[smart_id].population = self.smarts[smart_id].population + 1
		end
	end
end

-- установить squad и group в соответствии с работой
function simulation_board:setup_squad_and_group(obj)
	--alun_utils.debug_write(strformat("simulation_board:setup_squad_and_group %s",obj and obj:name()))
	local sim = alife()

	--' Сквад берем из смарта.
	local squad = sim:object(obj.group_id)
	if squad == nil then
		change_team_squad_group(obj, obj.team, 0, obj.group)
		return
	end
	
	local gg = game_graph()
	local group = obj.group --gg and gg:vertex(squad.m_game_vertex_id):level_id() or obj.group
	
	local smart = squad.assigned_target_id and sim:object(squad.assigned_target_id) or squad.smart_id and sim:object(squad.smart_id)
	if smart == nil then
		change_team_squad_group(obj, obj.team, obj.squad, group)
		return
	end
	local obj_sq = 0
	if smart:clsid() == clsid.smart_terrain then
		obj_sq = smart.squad_id
	end
	change_team_squad_group(obj, obj.team, obj_sq, group)
end

--' Заполнение стартового расположения
function simulation_board:fill_start_position()
	if self.start_position_filled == true then
		return
	end
	self.start_position_filled = true
	
	--alun_utils.debug_write(strformat("simulation_board:fill_start_position"))

	local gg = game_graph()
	local sim = alife()

	local n, result, id, value, smart, smrt_names, section_name, squad
	
	local setting_ini = ini_file("misc\\simulation.ltx")
	for level in gg:levels() do
		section_name = "start_position_" .. sim:level_name(level.id)
		if setting_ini:section_exist(section_name) then
			n = setting_ini:line_count(section_name)
			for i=0,n-1 do
				result, id, value	= setting_ini:r_line(section_name,i,"","")
				smrt_names = utils.parse_names(value)
				for k,v in pairs(smrt_names) do
					smart = self.smarts_by_names[v]
					if (smart) then
						squad = self:create_squad(smart, id)
					else
						printf("Wrong smart name [%s] in start position", tostring(v))
					end
				end
			end
		end
	end
end

--' Возвратить смарт по его имени.
function simulation_board:get_smart_by_name(name)
	return self.smarts_by_names[name]
end
--' Возвращает количество отрядов в смарте.
function simulation_board:get_smart_population(smart)
	return self.smarts[smart.id].population
end

--' Получение игрового поля.
function get_sim_board()
	if _G.SIMBOARD == nil then
		_G.SIMBOARD = simulation_board()
	end
	return _G.SIMBOARD
end

local available_targets = {}
function simulation_board:get_squad_target(squad)
	empty_table(available_targets)

	local most_priority_task = nil
	local max_prior = 0
	local curr_prior = 0
	local target_tbl
	local size = 0
	
	local pairs = pairs
	local object_registry = simulation_objects.get_sim_obj_registry().objects
	for k,v in pairs(object_registry) do
		curr_prior = 0
		if v.id ~= squad.id and not v.locked == true then
			curr_prior = v:evaluate_prior(squad)
		end
		if (curr_prior > 0 and v:target_precondition(squad)) then
			target_tbl = {prior = curr_prior, target = v}
			tinsert(available_targets, target_tbl)
			size = size + 1
		end
	end

	if size > 0 then
		tsort(available_targets, function(a,b) return a.prior > b.prior end)

		if (xr_conditions.surge_started() or is_squad_monster[squad.player_id]) then
			return available_targets[1].target
		end

		local max_id = math.floor(0.25 * size)
		if max_id == 0 then max_id = 1 end
		most_priority_task = available_targets[math.random(max_id)].target
	end

	return most_priority_task
end

--' Обнуление списка на создании игры.
function clear()
	_G.SIMBOARD = nil
end


------------------------------------------------------------------------------------
--    xr_campfire_point
-- Auto-generated point_jobs around smart_terrain bound campfires for gulag_general
-- by Alundaio
------------------------------------------------------------------------------------

-- TODO: Fix use_camp. It spams animations. use_camp manually set = false in add_to_binder.
-- Need to make it independent of sr_camp.script so that it doesn't require space_restrictors

evaid = 17000
actid = 17000

local used_vids = {}

------------------------------------------------------------------------------------
local alife, vector, level, mrand = alife, vector, level, math.random
------------------------------------------------------------------------------------
local assoc_tbl = 	{
						idle = {director = {"sit"}, listener = {"sit","sit_ass","sit_knee","sit_ass_weapon","sit_ass_eat_bread","sit_ass_drink_vodka","sit_ass_drink_energy","sit_ass_eat_kolbasa"}},
						harmonica = {director = {"play_harmonica"}, listener = {"sit","sit_ass","sit_knee","sit_ass_weapon","sit_ass_eat_bread","sit_ass_drink_vodka","sit_ass_drink_energy","sit_ass_eat_kolbasa"}},
						guitar = {director = {"play_guitar"}, listener = {"sit","sit_ass","sit_knee","sit_ass_weapon","sit_ass_eat_bread","sit_ass_drink_vodka","sit_ass_drink_energy","sit_ass_eat_kolbasa"}},
						story = {director = {"sit"}, listener = {"sit","sit_ass","sit_knee","sit_ass_weapon","sit_ass_eat_bread","sit_ass_drink_vodka","sit_ass_drink_energy","sit_ass_eat_kolbasa"}},
					}

function on_game_start()
	load_scheme("xr_campfire_point","campfire_point",0)
	--callback_register("scheme_set",set_scheme)
end

-----------------------------Private-----------------
local function get_rand_vertex(npc,vo,minD,maxD)
	local dir = utils.vector_copy_by_val(npc:position()):sub(vo:position())
	dir = vector_rotate_y(dir,mrand(360))
	return vo:vertex_in_direction(vo:level_vertex_id(),dir,mrand(minD,maxD))
end

-----------------------------------------------------

class "evaluator_need_job" (property_evaluator)
function evaluator_need_job:__init(storage, name) super(nil, name)
  	self.st = storage
end
function evaluator_need_job:evaluate()
  	return xr_logic.is_active(self.object, self.st) or false
end

----------------------------------------------------------------------------------------------------------------------
class "action_point_campfire" (action_base)
function action_point_campfire:__init (npc_name, action_name, storage) super(nil, action_name)
	self.st = storage
	self.st.approved_actions = {"play_harmonica","play_guitar","sit","sit_ass","sit_knee","sit_ass_weapon","sit_ass_eat_bread","sit_ass_drink_vodka","sit_ass_drink_energy","sit_ass_eat_kolbasa" }
end

function action_point_campfire:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
	self.object:set_path_type(game_object.level_path)
end

function action_point_campfire:activate_scheme()
	local vid,look
	if (self.st.smart) then
 		local fires = db.campfire_table_by_smart_names[self.st.smart]
		if (fires and not empty(fires)) then
			local campfire
			local t = {}
			local function create_campfire_point(pos,dir)
				local radius = 8
				local vertex_id = 4294967295
				local tmp_pos = vector():set(0,0,0)
				while (vertex_id >= 4294967295) do
					tmp_pos.x = pos.x + dir.x * radius
					tmp_pos.z = pos.z + dir.z * radius
					tmp_pos.y = pos.y

					vertex_id = level.vertex_id(tmp_pos)
					if (vertex_id >= 4294967295 or used_vids[vertex_id]) then
						if (radius > 1) then
							radius = radius - 1
						else
							break
						end
					end
				end
				return vertex_id
			end
			for id,camp in pairs(fires) do
				campfire = level.object_by_id(id)
				if (campfire) then 
					local dir = utils.vector_copy_by_val(campfire:direction())
					local pos = campfire:position()
					t[#t+1] = pos
					for i=1,6 do
						vid = create_campfire_point(pos,vector_rotate_y(dir,i*60))
						look = pos
						if (vid and vid < 4294967295 and not used_vids[vid]) then 
							break 
						end
					end
				end
				if (vid and vid < 4294967295 and not used_vids[vid]) then 
					break 
				end
			end
			
			-- fallback no camp or all space is taken
			if (vid == nil or vid >= 4294967295 or used_vids[vid]) then
				local pos = t and #t > 0 and t[math.random(#t)] or self.object:position()
				vid = alun_utils.find_random_cover(self.object,pos,5,15)
				look = pos
			end
		end
	end
	
	-- fallback if no campfires
	if (vid == nil or vid >= 4294967295 or used_vids[vid]) then
		local smart = self.st.smart and SIMBOARD:get_smart_by_name(self.st.smart) or xr_gulag.get_npc_smart(self.object)
		local pos = smart and smart.position or self.object:position()
		vid = alun_utils.find_random_cover(self.object,pos,5,15)
		look = pos
	end
	
	self.st.signals = {}
	self.st.look_position = look
	self.st.vid = utils.send_to_nearest_accessible_vertex(self.object,vid or self.object:level_vertex_id())
	state_mgr.set_state(self.object,xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.reach_movement))
	
	used_vids[self.st.vid] = true
end

function action_point_campfire:execute()
	action_base.execute(self)

	if not (self.st.vid) then 
		return 
	end 
	
	local npc = self.object
	if not (npc:level_vertex_id() == self.st.vid) then
		if (npc:path_type() ~= game_object.level_path) then 
			npc:set_path_type(game_object.level_path)
		end
		self.st.vid = utils.send_to_nearest_accessible_vertex(npc,self.st.vid,"xr_campfire_point")
		state_mgr.set_state(npc,xr_logic.pick_section_from_condlist(db.actor, npc, self.st.reach_movement))
		return
	end

	if (self.st.use_camp and not self.st.camp and not self.st.camp_checked) then
		self.st.camp_checked = true
		local camp = sr_camp.get_current_camp(npc:position())
		if (camp) then
			self.st.camp = camp
			camp:register_npc(npc:id())
		end
	end

	local tg = time_global()

	if (not self.st.camp and self.st.sound_idle) then
		self.st.__sound_idle = self.st.__sound_idle or tg + mrand(10000,30000)

		if (tg > self.st.__sound_idle) then
			xr_sound.set_sound_play(self.object:id(), self.st.sound_idle)
			self.st.__sound_idle = nil
		end
	end

	local anim = self:get_camp_action() or xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.anim)
	state_mgr.set_state(self.object, anim, nil, nil, {look_position = self.st.look_position})
end

function action_point_campfire:get_camp_action()
	if not (self.st.camp) then
		return
	end

	local camp_action, is_director = self.st.camp:get_camp_action(self.object:id())
	if not (camp_action) then 
		return 
	end
	
	if (self.current_action and self.current_action ~= "play_guitar" and self.current_action ~= "play_harmonica") then 
		self.__dtimer = not self.__dtimer and time_global() + math.random(10000,15000) or self.__dtimer
		if (time_global() < self.__dtimer) then
			return
		end
	end 
	
	local role = is_director and "director" or "listener"
	local tbl = assoc_tbl[camp_action][role]
	
	self.current_action = tbl and tbl[mrand(#tbl)] or "sit_ass"

	return self.current_action
end

function action_point_campfire:finalize()
	action_base.finalize(self)
	if (self.st.camp) then
		self.st.camp:unregister_npc(self.object:id())
	end
	self.st.camp_checked = nil
	if (self.st.vid) then
		used_vids[self.st.vid] = nil
	end
end

function action_point_campfire:position_riched()
	return self.cover_position:distance_to_sqr(self.object:position()) <= 0.4
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	local wp = world_property
	local manager = npc:motivation_action_manager()

	-- evaluators
	manager:add_evaluator(evaid, this.evaluator_need_job(storage, "need_cover"))

	local new_action = this.action_point_campfire(npc, "action_point_campfire", storage)
	new_action:add_precondition( wp(stalker_ids.property_alive,true) )
	new_action:add_precondition( wp(stalker_ids.property_danger,false) )
	--new_action:add_precondition( wp(xr_danger.evaid,false) )
	new_action:add_precondition( wp(stalker_ids.property_enemy,false) )
	new_action:add_precondition( wp(stalker_ids.property_anomaly,false) )
	new_action:add_precondition( wp(xr_evaluators_id.sidor_wounded_base,false) )
	new_action:add_precondition( wp(evaid,true) )

	new_action:add_effect( wp(evaid,false) )
	new_action:add_effect ( wp(xr_evaluators_id.state_mgr + 4, false) )
	manager:add_action(actid, new_action)

	xr_logic.subscribe_action_for_events(npc, storage, new_action)

	-- actions
	new_action = manager:action(xr_actions_id.alife)
	new_action:add_precondition( wp(evaid, false) )
	new_action = manager:action(xr_actions_id.state_mgr + 2)
	new_action:add_precondition( wp(evaid, false) )
end

function set_scheme(npc, ini, scheme, section, gulag_name, stype)
	local st = xr_logic.assign_storage_and_bind(npc, ini, "campfire_point", section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)

	st.sound_idle= utils.cfg_get_string(ini, section, "sound_idle",npc, false, "")
	st.smart = utils.cfg_get_string(ini, section, "smart", npc, false, "")
	st.anim	= xr_logic.parse_condlist(npc, "anim", "anim", utils.cfg_get_string(ini, section, "anim", npc, false, "", "hide"))
	st.reach_movement = xr_logic.parse_condlist(npc, "reach_movement", "reach_movement", utils.cfg_get_string(ini, section, "reach_movement", npc, false, "", "patrol"))

	local use_camp = xr_logic.parse_condlist(npc, "use_camp", "use_camp", utils.cfg_get_string(ini, section, "use_camp", npc, false, "", "false"))
	st.use_camp = xr_logic.pick_section_from_condlist(db.actor, npc, use_camp) == "true"
end

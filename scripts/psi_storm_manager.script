--------------------------------------------------------------------------------
-- Psi Storm manager class -----------------------------------------------------
-- Made by Cromm Cruac ---------------------------------------------------------
-- for AtmosFear 3 -------------------------------------------------------------
-- 25.06.2011 ------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Modified by Alundaio
	-- (see surge_manager.script)
	-- removed duplicate functions also used by surge_manager

---------------------------------------------------------------------
-- class instance
PsiStormManager = nil
---------------------------------------------------------------------

local prev_sec 			= -1
local prev_game_sec 		= -1
local diff_sec 			= -1
local diff_game_sec		= -1
local min_psi_storm_time 	= 12*60*60
local max_psi_storm_time 	= 24*60*60
local artifact_chance 		= 0.05

local function actor_on_update(binder,delta)
	PsiStormManager:update()
end

local function actor_on_init(binder)
	if not (PsiStormManager) then 
		PsiStormManager = CPsiStormManager()
	end
end

function on_game_start()
	if not (USE_MARSHAL) then
		RegisterScriptCallback("actor_on_load",this.actor_on_load)
		RegisterScriptCallback("actor_on_save",this.actor_on_save)
	else 
		RegisterScriptCallback("actor_on_load",this.actor_on_load) -- for initialize()
		RegisterScriptCallback("load_state",this.load_state)
		RegisterScriptCallback("save_state",this.save_state)
	end
	RegisterScriptCallback("actor_on_update",actor_on_update)
	RegisterScriptCallback("actor_on_init",actor_on_init)
end

class "CPsiStormManager"
function CPsiStormManager:__init()
	self.artifacts = { 	af_electra_flash 		= 0.25,
						af_dummy_dummy 			= 0.10,
						af_ice 					= 0.05,
						af_electra_moonlight	= 0.45,
						af_cristall_flower 		= 0.15
						}
end

function CPsiStormManager:initialize()
	self.ini = surge_manager.SurgeManager.ini
	if not (self._state_loaded) then 
		self.game_time_factor=level.get_time_factor()
		self.last_psi_storm_time = game.get_game_time()
		self.inited_time = self.last_psi_storm_time
		self.started = false
		self.finished = true
		self.loaded = false
		self.task_given = nil
	end 
	
	self.vortex_index=0
	self.vortex_period_min=8
	self.vortex_period_max=16
	self.vortex_distance_max=150
	self.next_vortex_at=nil
	self.max_distance_psi_hit=200
	self.max_distance_electro_hit=50
	self.max_distance_npc_hit=50
	self.psi_storm_duration = 254 -- (duration: about 40mins of game time)

	self.psi_storm_message 		= ""
	self.psi_storm_task_sect 	= ""
	
	self.time_forwarded = false
	
	local freq = atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_psi_storm_freq",2,24)
	min_psi_storm_time=math.floor(freq/2)*3600
	max_psi_storm_time=freq*3600
	self._delta = math.random(min_psi_storm_time, max_psi_storm_time)
end

function CPsiStormManager:start(manual)
	if not (self.loaded) then
		printf("CPsiStormManager: Not loaded!")
		return 
	end 
	self.game_time_factor=level.get_time_factor()

	local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
	Y, M, D, h, m, s, ms = self.last_psi_storm_time:get(Y, M, D, h, m, s, ms)
	if(manual or not self.inited_time) then
		self.inited_time = game.get_game_time()
	else
		self.inited_time:set(Y, M, D, h, m, s + self._delta, ms)
	end

	diff_sec = math.ceil(game.get_game_time():diffSec(self.inited_time)/level.get_time_factor())
	local level_name = level.name()
	if(level_name == "l11_hospital" or atmosfear.valid_levels[level_name] ~= true or atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_enable_psi_storm",2,1)==0) then
		self:skip_psi_storm()
		return
	end
	if(diff_sec+6>self.psi_storm_duration) then
		self:skip_psi_storm()
	else
		self.started = true
		self.finished = false
		self.hitFactor=0
		self.stages = empty_table(self.stages)
		self.vortexes = empty_table(self.vortexes)
		self.humanParticles = empty_table(self.humanParticles)
		self.next_vortex_at = nil
		level.set_time_factor(10)
		self.task_given = nil
	end
end

function CPsiStormManager:new_psi_storm_time(reset)
	if reset then
		self.last_psi_storm_time 	= game.get_game_time()
	end
	self.last_psi_storm_time 	= game.get_game_time()
	local freq = atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_psi_storm_freq",2,24)
	min_psi_storm_time		= math.floor(freq/2)*3600
	max_psi_storm_time		= freq*3600
	self._delta 			= math.random(min_psi_storm_time, max_psi_storm_time)

	local g_time = game.get_game_time()
	local psi_storm_start = math.floor(self._delta - g_time:diffSec(self.last_psi_storm_time))
	local psi_storm_end = math.floor(self._delta+3600 - g_time:diffSec(self.last_psi_storm_time))
	local surge_start = math.floor(surge_manager.SurgeManager._delta - g_time:diffSec(surge_manager.SurgeManager.last_surge_time))
	local surge_end = math.floor(surge_manager.SurgeManager._delta+3600 - g_time:diffSec(surge_manager.SurgeManager.last_surge_time))
	if ((psi_storm_end > surge_start) and (psi_storm_end < surge_end)) then
		--1h earlier
		self._delta=self._delta-3600
	end
	if ((psi_storm_start > surge_start) and (psi_storm_start < surge_end)) then
		--1h later
		self._delta=self._delta+3600
	end
end

function CPsiStormManager:skip_psi_storm()
	local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
	Y, M, D, h, m, s, ms = self.inited_time:get(Y, M, D, h, m, s, ms)
	self.last_psi_storm_time:set(Y, M, D, h, m, s + self.psi_storm_duration, ms)

	self:new_psi_storm_time(false)

	self.started 			= false
	self.finished 			= true

	self.psi_storm_message 		= ""
	self.psi_storm_task_sect 	= ""
	self.task_given 		= nil
	prev_sec				= 0
	level.set_time_factor(self.game_time_factor)
end

function CPsiStormManager:finish(manual)
	self.started 			= false
	self.finished 			= true
	self.last_psi_storm_time 	= game.get_game_time()

	self:new_psi_storm_time(false)

	for k,v in pairs(db.signal_light) do
		v:stop_light()
		v:stop()
	end

	self.psi_storm_message 		= ""
	self.psi_storm_task_sect 	= ""
	self.task_given = nil

	if(manual or (self.time_forwarded and level_weathers.get_weather_manager().weather_fx)) then
		for key,vortex in pairs(self.vortexes) do
			vortex.effect:stop()
			vortex.sound:stop()
		end
		level.stop_weather_fx()
		level_weathers.get_weather_manager():forced_weather_change()
	end
	for k,snd in pairs(surge_manager.SurgeManager.blowout_sounds) do
		if snd ~= nil and snd:playing() then
			snd:stop()
		end
	end
	prev_sec = 0
	
	for k,v in pairs(self.humanParticles) do 
		v:stop()
	end 
	
	self.humanParticles = empty_table(self.humanParticles)
	self.vortexes = empty_table(self.vortexes)
	self.stages = empty_table(self.stages)

	level.set_time_factor(self.game_time_factor)
end

function distance_2d(p1, p2)
	--return math.sqrt( (b.x-a.x)^2 + (b.z-a.z)^2 )
	return p1:distance_to_xz(p2)
end

function distance_3d(p1, p2)
	--return math.sqrt( (b.x-a.x)^2 + (b.z-a.z)^2 )
	return p1:distance_to(p2)
end

-- ###############################################################################################
--                                  UPDATE
-- ###############################################################################################

function CPsiStormManager:update()
	if(device().precache_frame > 1) then
		return
	end
	if not (self.loaded) then
		return 
	end 
	if not(self.started) then
		local g_time = game.get_game_time()
		if(self.time_forwarded) then
			local diff = math.abs(self._delta - g_time:diffSec(self.last_psi_storm_time))
			if(diff<3600) then
				self._delta = 3*3600+g_time:diffSec(self.last_psi_storm_time)
			end
			self.time_forwarded = false
		end
		if(g_time:diffSec(self.last_psi_storm_time) < self._delta) then
			return
		end
		self:start()
		return
	end

	diff_sec = math.ceil(game.get_game_time():diffSec(self.inited_time)/level.get_time_factor())
	local actor_pos=db.actor:position()
	if(prev_sec~=diff_sec) then
		prev_sec = diff_sec
		local level_name = level.name()
		if(level_name == "l11_hospital" or atmosfear.valid_levels[level_name] ~= true or atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_enable_psi_storm",2,1)==0) then
			self:finish()
			return
		end
		if(diff_sec>=self.psi_storm_duration) then
			self:finish()
		else
			surge_manager.SurgeManager:calculate_best_surge_cover()
			-- psi storm begins -----------------------------------------------------------------------------------------------------------------------------------------
			if (diff_sec>=0) and (self.stages['beginning']==nil) then
				if (level.get_time_hours() >= 5 and level.get_time_hours() <= 20) then
					level.set_weather_fx("fx_psi_storm_day")
				else
					level.set_weather_fx("fx_psi_storm_night")
				end
				self.stages['beginning']=true
			end
			-- siren warning -----------------------------------------------------------------------------------------------------------------------------------------
			if (diff_sec>=22) and (self.stages['siren']==nil) and (atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_psi_storm_warning",0,"siren")=="siren") then
				self:launch_rockets()
				surge_manager.SurgeManager:play_siren_sound()
				self.stages['siren']=true
			end
			-- psi storm warning -----------------------------------------------------------------------------------------------------------------------------------------
			if (diff_sec>=24) and not(self.task_given) then
				if atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_psi_storm_task",0,"give")=="give" then
					self:give_psi_storm_hide_task()
				end
				self.task_given = true
			end
			-- psi storm main phase -----------------------------------------------------------------------------------------------------------------------------------------
			if (diff_sec>=40) and (diff_sec<=228) then
				if self.next_vortex_at == nil then
					self.next_vortex_at = diff_sec + math.random(self.vortex_period_min, self.vortex_period_max)
				end
				if self.next_vortex_at == diff_sec then
					self:vortex()
					self.next_vortex_at = diff_sec + math.random(self.vortex_period_min, self.vortex_period_max)
				end
			end
			for key,vortex in pairs(self.vortexes) do
				local life_time=diff_sec-vortex.start_time
				if life_time>=20 and vortex.hit==false then
					self:kill_crows_at_pos(vortex.sound_pos)
					self:spawn_artefact(vortex.sound_pos)
					if (atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_psi_storm_fate",0,"unhurt")~="unhurt") then
						self:kill_obj_at_pos(vortex.sound_pos)
					end
					if not (surge_manager.actor_in_cover()) then
						self:vortex_actor_hit(vortex)
					end
					vortex.hit=true
				end
				if life_time>=25 then
					vortex=nil
				end
			end
		end
	end
end


-- ###############################################################################################
function CPsiStormManager:vortex()
	self.vortex_index=self.vortex_index+1
	local effect=particles_object("crommcruac\\psi_storm_01")
	local sound=sound_object("anomaly\\psi_storm_01")
	local actor_pos=db.actor:position()
	local angle_dec=math.random(0,359)
	local angle_rad=math.rad(angle_dec)
	local distance=math.random(0,self.vortex_distance_max)
	local pos_x=math.cos(angle_rad)*distance
	local pos_z=math.sin(angle_rad)*distance
	local particle_pos=vector():set(actor_pos.x+pos_x, actor_pos.y+20, actor_pos.z+pos_z)
	local sound_pos=vector():set(actor_pos.x+pos_x, actor_pos.y+60, actor_pos.z+pos_z)
	self.vortexes[self.vortex_index]={effect=effect, particle_pos=particle_pos,sound=sound, sound_pos=sound_pos, start_time=diff_sec, hit=false}
	--particle
	self.vortexes[self.vortex_index].effect:play_at_pos(self.vortexes[self.vortex_index].particle_pos)
	--sound
	if self.vortexes[self.vortex_index].sound ~= nil and self.vortexes[self.vortex_index].sound:playing() then
		self.vortexes[self.vortex_index].sound:stop()
	end
	if self.vortexes[self.vortex_index].sound ~= nil then
		self.vortexes[self.vortex_index].sound:play_at_pos(db.actor, self.vortexes[self.vortex_index].sound_pos)
		self.vortexes[self.vortex_index].sound.volume = 1
	end
end

function CPsiStormManager:spawn_artefact(pos)
	local sum=0
	for artefact,prob in pairs(self.artifacts) do
		sum=sum+prob
	end
	local rnd=math.random()*sum
	local artefact_to_spawn
	for artefact,prob in pairs(self.artifacts) do
		artefact_to_spawn=artefact
		rnd=rnd-prob
		if (rnd<=0) then
			break
		end
	end
	local chance = math.random(1,100)/100
	--af_electra_flash 4000ru, af_dummy_dummy 12000, af_ice 18000, af_electra_moonlight 6000,af_cristall_flower 3000
	if chance <= artifact_chance then
		alife():create(artefact_to_spawn, pos, 0, 0, -1)
	else
	end
end

function CPsiStormManager:vortex_actor_hit(vortex)
	local hit_power=0
	local distance = distance_2d(db.actor:position(), vortex.particle_pos)
	if distance < self.max_distance_psi_hit then
		hit_power=math.cos(distance * math.pi / self.max_distance_psi_hit)+1
		local h = hit()
		h.type = hit.telepatic
		h.power = surge_manager.SurgeManager:hit_power(hit_power, h.type)
		h.impulse = 0
		h.direction = vector():set(0,0,1)
		h.draftsman = db.actor
		if not(atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_god_mode",1,false)) then
			db.actor:hit(h)
		end
		level.remove_pp_effector(666)
		level.add_pp_effector("psi_fade.ppe", 666, false)
		level.set_pp_effector_factor(666,h.power)
	end
	if distance < self.max_distance_electro_hit then
		hit_power=math.cos(distance * math.pi / self.max_distance_electro_hit)+1
		local h = hit()
		h.type = hit.shock
		h.power = surge_manager.SurgeManager:hit_power(hit_power, h.type)
		h.impulse = 0
		h.direction = vector():set(0,0,1)
		h.draftsman = db.actor
		if not(atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_god_mode",1,false)) then
			db.actor:hit(h)
		end
		level.remove_pp_effector(667)
		level.add_pp_effector("electro_fade.ppe", 667, false)
		level.set_pp_effector_factor(667,h.power)
	end
end

function CPsiStormManager:kill_obj_at_pos(pos)
	local board = SIMBOARD
	local sim,gg = alife(),game_graph()
	local immuned_to_surge_squads = {
		["monolith"] 				= true,
		["monster_predatory_day"] 	= true,
		["monster_predatory_night"] = true,
		["monster_vegetarian"] 		= true,
		["monster_zombied_day"] 	= true,
		["monster_zombied_night"] 	= true,
		["monster_special"] 		= true,
		["monster"]					= true,
		["zombied"]					= true
	}
	for k,v in pairs(board.squads) do
		local squad = v
		if (squad:clsid() == clsid.online_offline_group_s and surge_manager.can_destroy_squad(squad,immuned_to_surge_squads,sim,gg)) then
			local squad_npcs = surge_manager.get_squad_members(squad.id)
			local fate = atmosfear_options.config:GetValue("atmosfear_current_parameters","opt_psi_storm_fate",0,"kill")
			for kk,vv in pairs(squad_npcs) do
				local obj = alife():object(kk)
				if(obj and not(get_object_story_id(obj.id))) then
					if(surge_manager.check_squad_smart_props(squad.id)) then
						local cl_obj = level.object_by_id(obj.id)
						if cl_obj ~= nil then
							if distance_2d(pos, cl_obj:position())<self.max_distance_npc_hit then
								self.humanParticles[k.."_"..kk]=particles_object("crommcruac\\electrocute_human")
								self.humanParticles[k.."_"..kk]:play_at_pos(cl_obj:position())
								if fate=="turntozombie" then
									self:turn_to_zombie(obj)
								else
									cl_obj:kill(cl_obj)
								end
							end
						else
							if distance_2d(pos, obj.position)<self.max_distance_npc_hit then
								self.humanParticles[k.."_"..kk]=particles_object("crommcruac\\electrocute_human")
								self.humanParticles[k.."_"..kk]:play_at_pos(obj:position())
								if fate=="turntozombie" then
									self:turn_to_zombie(obj)
								else
									obj:kill()
								end
							end
						end
					else
						if(surge_manager.SurgeManager:pos_in_cover(obj.position)) then
							local cl_obj = level.object_by_id(obj.id)
							if cl_obj ~= nil then
								if distance_2d(pos, cl_obj:position())<self.max_distance_npc_hit then
									self.humanParticles[k.."_"..kk]=particles_object("crommcruac\\electrocute_human")
									self.humanParticles[k.."_"..kk]:play_at_pos(cl_obj:position())
									if fate=="turntozombie" then
										self:turn_to_zombie(obj)
									else
										cl_obj:kill(cl_obj)
									end
								end
							else
								if distance_2d(pos, obj.position)<self.max_distance_npc_hit then
									self.humanParticles[k.."_"..kk]=particles_object("crommcruac\\electrocute_human")
									self.humanParticles[k.."_"..kk]:play_at_pos(obj:position())
									if fate=="turntozombie" then
										self:turn_to_zombie(obj)
									else
										obj:kill()
									end
								end
							end
						end
					end
				end
			end
		end
	end
	--self.debugMessages[10]:SetText("obj to kill:"..tostring(#self.objects_to_kill))
end

function CPsiStormManager:turn_to_zombie(obj)
	CreateDelayedEvent(obj.id,"turn_to_zombie",math.random(1,8),surge_manager.make_zombied,obj.id)
	--self.debugMessages[1]:SetText("type: "..tostring(zombie_type))
end

function CPsiStormManager:kill_crows_at_pos(pos)
	--self.crowParticles={}
	local h = hit()
	h.type = hit.fire_wound
	h.power = 1.0
	h.impulse = 0
	h.direction = vector():set(0,0,1)
	h.draftsman = db.actor
	for k,v in pairs(bind_crow.crow_storage) do
		local obj = alife():object(v)
		if obj then
			local crow = level.object_by_id(obj.id)
			if(crow and crow:alive() and distance_2d(pos, crow:position())<25) then
				--crow:start_particles("crommcruac\\electrocute_crow","bip01_pelvis")
				--self.crowParticles[k]=particles_object("crommcruac\\electrocute_crow")
				--self.crowParticles[k]:play_at_pos(crow:position())
				crow:hit(h)
			end
		end
	end
end

function CPsiStormManager:launch_rockets()
	for k,v in pairs(db.signal_light) do
		if not(v:is_flying()) then
			v:launch()
		end
	end
end

function save_state(m_data)
	if not (m_data.PsiStormManager) then 
		m_data.PsiStormManager = {}
	end
	
	local mgr = PsiStormManager
	if not (mgr.loaded) then
		mgr:initialize()
		mgr.loaded = true
	end
	
	m_data.PsiStormManager.finished = mgr.finished 
	m_data.PsiStormManager.started = mgr.started
	m_data.PsiStormManager.last_psi_storm_time = utils.CTime_to_table(mgr.last_psi_storm_time)
	if (mgr.started) then 
		m_data.PsiStormManager.inited_time = utils.CTime_to_table(mgr.inited_time)
		m_data.PsiStormManager.task_given = mgr.task_given
		m_data.PsiStormManager.game_time_factor = mgr.game_time_factor
	end
	m_data.PsiStormManager._delta = mgr._delta
end 

function load_state(m_data)
	if not (m_data.PsiStormManager) then 
		return
	end
	if not (PsiStormManager) then 
		PsiStormManager = CPsiStormManager()
	end
	local mgr = PsiStormManager
	mgr.finished = m_data.PsiStormManager.finished
	mgr.started = m_data.PsiStormManager.started
	mgr.last_psi_storm_time = utils.CTime_from_table(m_data.PsiStormManager.last_psi_storm_time)
	if (mgr.started) then 
		mgr.inited_time = utils.CTime_from_table(m_data.PsiStormManager.inited_time)
		mgr.task_given = m_data.PsiStormManager.task_given
		mgr.game_time_factor = m_data.PsiStormManager.game_time_factor
		mgr.stages = empty_table(mgr.stages)
		mgr.humanParticles = empty_table(mgr.humanParticles)
		mgr.vortexes = empty_table(mgr.vortexes)
		mgr.stages = empty_table(mgr.stages)
	end
	mgr._delta = m_data.PsiStormManager._delta
	mgr._state_loaded = true
end 

function actor_on_save(binder,packet)
	if (USE_MARSHAL) then 
		return 
	end
	-- load defaults if not loaded
	local mgr = PsiStormManager
	if not (mgr.loaded) then
		mgr:initialize()
		mgr.loaded = true
	end
	set_save_marker(packet, "save", false, "PsiStorm")
	packet:w_bool(mgr.finished)
	packet:w_bool(mgr.started)
	utils.w_CTime(packet, mgr.last_psi_storm_time)
	if(mgr.started) then
		utils.w_CTime(packet, mgr.inited_time)
		packet:w_bool(mgr.task_given)
		packet:w_u32(mgr.game_time_factor)
	end
	packet:w_u32(mgr._delta)
	set_save_marker(packet, "save", true, "PsiStorm")
end 

function actor_on_load(binder,packet)
	if not (PsiStormManager) then 
		PsiStormManager = CPsiStormManager()
	end
	local mgr = PsiStormManager
	if not (mgr.loaded) then
		mgr:initialize()
		mgr.loaded = true
	end
	if (USE_MARSHAL) then 
		return 
	end 
	set_save_marker(packet, "load", false, "PsiStorm")
	mgr.finished = packet:r_bool()
	mgr.started = packet:r_bool()
	mgr.last_psi_storm_time = utils.r_CTime(packet)
	if(mgr.started) then
		mgr.inited_time = utils.r_CTime(packet)
		mgr.task_given = packet:r_bool()
		mgr.game_time_factor = packet:r_u32()
		mgr.stages = empty_table(mgr.stages)
		mgr.humanParticles = empty_table(mgr.humanParticles)
		mgr.vortexes = empty_table(mgr.vortexes)
		mgr.stages = empty_table(mgr.stages)
	end
	mgr._delta = packet:r_u32()
	set_save_marker(packet, "load", true, "PsiStorm")
end 

function CPsiStormManager:give_psi_storm_hide_task()
	if(self.psi_storm_message~="empty") then
		local mess = ""
		if(self.psi_storm_message=="") then
			local time = 0
			mess = game.translate_string("hide_from_psi_storm_message")
		else
			mess = game.translate_string(self.psi_storm_message)
		end
	end
	if(self.psi_storm_task_sect~="empty") then
		if(self.psi_storm_task_sect=="") then
			task_manager.get_task_manager():give_task("hide_from_psi_storm")
		else
			task_manager.get_task_manager():give_task(self.psi_storm_task_sect)
		end
	end
end

function is_started()
	return PsiStormManager.started
end

function is_finished()
	return PsiStormManager.finished == true
end

function is_loaded()
	return PsiStormManager.loaded == true
end

function get_task_title()
	local title = ""
	if(surge_manager.actor_in_cover()) then
		title = "hide_from_psi_storm_name_2"
	else
		title = "hide_from_psi_storm_name_1"
	end
	return title
end

function get_task_descr()
	local descr = ""
	if(surge_manager.actor_in_cover()) then
		descr = game.translate_string("hide_from_psi_storm_descr_2_a")
	else
		descr = game.translate_string("hide_from_psi_storm_descr_1_a")
	end
	return descr
end

function get_task_target()
	if(surge_manager.actor_in_cover()) then
		return nil
	end
	local m = surge_manager.SurgeManager
	return m.best_cover and m.best_cover:id()
end
